/*! (c) 2019-2021 pixiv Inc. - https://github.com/pixiv/three-vrm/blob/release/LICENSE */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE_VRM={},e.THREE)}(this,(function(e,t){"use strict";function i(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(i){if("default"!==i){var n=Object.getOwnPropertyDescriptor(e,i);Object.defineProperty(t,i,n.get?n:{enumerable:!0,get:function(){return e[i]}})}})),t.default=e,Object.freeze(t)}var n=i(t);
/*!
     * @pixiv/three-vrm-core v1.0.0-beta.7
     * The implementation of core features of VRM, for @pixiv/three-vrm
     *
     * Copyright (c) 2020-2021 pixiv Inc.
     * @pixiv/three-vrm-core is distributed under MIT License
     * https://github.com/pixiv/three-vrm/blob/release/LICENSE
     */class r extends n.Object3D{constructor(e){super(),this.weight=0,this.isBinary=!1,this.overrideBlink="none",this.overrideLookAt="none",this.overrideMouth="none",this._binds=[],this.name=`VRMExpression_${e}`,this.expressionName=e,this.type="VRMExpression",this.visible=!1}get overrideBlinkAmount(){return"block"===this.overrideBlink?0<this.weight?1:0:"blend"===this.overrideBlink?this.weight:0}get overrideLookAtAmount(){return"block"===this.overrideLookAt?0<this.weight?1:0:"blend"===this.overrideLookAt?this.weight:0}get overrideMouthAmount(){return"block"===this.overrideMouth?0<this.weight?1:0:"blend"===this.overrideMouth?this.weight:0}addBind(e){this._binds.push(e)}applyWeight(e){var t;let i=this.isBinary?0===this.weight?0:1:this.weight;i*=null!==(t=null==e?void 0:e.multiplier)&&void 0!==t?t:1,this._binds.forEach((e=>e.applyWeight(i)))}clearAppliedWeight(){this._binds.forEach((e=>e.clearAppliedWeight()))}}
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */function o(e,t,i,n){return new(i||(i=Promise))((function(r,o){function s(e){try{l(n.next(e))}catch(e){o(e)}}function a(e){try{l(n.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?r(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(s,a)}l((n=n.apply(e,t||[])).next())}))}function s(e,t,i){const n=e.parser.json.nodes[t].mesh;if(null==n)return null;const r=e.parser.json.meshes[n],o=[];if(i.isMesh)o.push(i);else{const e=r.primitives.length;for(let t=0;t<e;t++)o.push(i.children[t])}return o}function a(e,t){return o(this,void 0,void 0,(function*(){const i=yield e.parser.getDependency("node",t);return s(e,t,i)}))}function l(e){return o(this,void 0,void 0,(function*(){const t=yield e.parser.getDependencies("node"),i=new Map;return t.forEach(((t,n)=>{const r=s(e,n,t);null!=r&&i.set(n,r)})),i}))}function u(e,t){var i,r;let o=null;if(parseInt(n.REVISION,10)>=133)o=null!==(r=null===(i=e.associations.get(t))||void 0===i?void 0:i.materials)&&void 0!==r?r:null;else{const i=e.associations.get(t);"materials"===(null==i?void 0:i.type)&&(o=i.index)}return o}const d={Aa:"aa",Ih:"ih",Ou:"ou",Ee:"ee",Oh:"oh",Blink:"blink",Happy:"happy",Angry:"angry",Sad:"sad",Relaxed:"relaxed",LookUp:"lookUp",Surprised:"surprised",LookDown:"lookDown",LookLeft:"lookLeft",LookRight:"lookRight",BlinkLeft:"blinkLeft",BlinkRight:"blinkRight",Neutral:"neutral"};function h(e){return Math.max(Math.min(e,1),0)}class c{constructor(){this.blinkExpressionNames=["blink","blinkLeft","blinkRight"],this.lookAtExpressionNames=["lookLeft","lookRight","lookUp","lookDown"],this.mouthExpressionNames=["aa","ee","ih","oh","ou"],this._expressions=[],this._expressionMap={}}get expressions(){return this._expressions.concat()}get expressionMap(){return Object.assign({},this._expressionMap)}get presetExpressionMap(){const e={},t=new Set(Object.values(d));return Object.entries(this._expressionMap).forEach((([i,n])=>{t.has(i)&&(e[i]=n)})),e}get customExpressionMap(){const e={},t=new Set(Object.values(d));return Object.entries(this._expressionMap).forEach((([i,n])=>{t.has(i)||(e[i]=n)})),e}copy(e){return this._expressions.concat().forEach((e=>{this.unregisterExpression(e)})),e._expressions.forEach((e=>{this.registerExpression(e)})),this.blinkExpressionNames=e.blinkExpressionNames.concat(),this.lookAtExpressionNames=e.lookAtExpressionNames.concat(),this.mouthExpressionNames=e.mouthExpressionNames.concat(),this}clone(){return(new c).copy(this)}getExpression(e){var t;return null!==(t=this._expressionMap[e])&&void 0!==t?t:null}registerExpression(e){this._expressions.push(e),this._expressionMap[e.expressionName]=e}unregisterExpression(e){const t=this._expressions.indexOf(e);-1===t&&console.warn("VRMExpressionManager: The specified expressions is not registered"),this._expressions.splice(t,1),delete this._expressionMap[e.expressionName]}getValue(e){var t;const i=this.getExpression(e);return null!==(t=null==i?void 0:i.weight)&&void 0!==t?t:null}setValue(e,t){const i=this.getExpression(e);i&&(i.weight=h(t))}getExpressionTrackName(e){const t=this.getExpression(e);return t?`${t.name}.weight`:null}update(){const e=this._calculateWeightMultipliers();this._expressions.forEach((e=>{e.clearAppliedWeight()})),this._expressions.forEach((t=>{let i=1;const n=t.expressionName;-1!==this.blinkExpressionNames.indexOf(n)&&(i*=e.blink),-1!==this.lookAtExpressionNames.indexOf(n)&&(i*=e.lookAt),-1!==this.mouthExpressionNames.indexOf(n)&&(i*=e.mouth),t.applyWeight({multiplier:i})}))}_calculateWeightMultipliers(){let e=1,t=1,i=1;return this._expressions.forEach((n=>{e-=n.overrideBlinkAmount,t-=n.overrideLookAtAmount,i-=n.overrideMouthAmount})),e=Math.max(0,e),t=Math.max(0,t),i=Math.max(0,i),{blink:e,lookAt:t,mouth:i}}}const p=new n.Color;class m{constructor({material:e,type:t,targetValue:i}){var n,r,o;this.material=e,this.type=t,this.targetValue=i;const s=null===(n=Object.entries(m._propertyNameMapMap).find((([t])=>!0===e[t])))||void 0===n?void 0:n[1],a=null!==(r=null==s?void 0:s[t])&&void 0!==r?r:null;if(null==a)console.warn(`Tried to add a material color bind to the material ${null!==(o=e.name)&&void 0!==o?o:"(no name)"}, the type ${t} but the material or the type is not supported.`),this._state=null;else{const t=e[a].clone(),i=this.targetValue.clone().sub(t);this._state={propertyName:a,initialValue:t,deltaValue:i}}}applyWeight(e){if(null==this._state)return;const{propertyName:t,deltaValue:i}=this._state,n=this.material[t];void 0!==n&&(n.add(p.copy(i).multiplyScalar(e)),"boolean"==typeof this.material.shouldApplyUniforms&&(this.material.shouldApplyUniforms=!0))}clearAppliedWeight(){if(null==this._state)return;const{propertyName:e,initialValue:t}=this._state,i=this.material[e];void 0!==i&&(i.copy(t),"boolean"==typeof this.material.shouldApplyUniforms&&(this.material.shouldApplyUniforms=!0))}}m._propertyNameMapMap={isMeshStandardMaterial:{color:"color",emissionColor:"emissive"},isMeshBasicMaterial:{color:"color"},isMToonMaterial:{color:"color",emissionColor:"emissive",outlineColor:"outlineFactor",rimColor:"rimFactor",shadeColor:"shadeFactor"}};class f{constructor({primitives:e,index:t,weight:i}){this.primitives=e,this.index=t,this.weight=i}applyWeight(e){this.primitives.forEach((t=>{var i;null!=(null===(i=t.morphTargetInfluences)||void 0===i?void 0:i[this.index])&&(t.morphTargetInfluences[this.index]+=this.weight*e)}))}clearAppliedWeight(){this.primitives.forEach((e=>{var t;null!=(null===(t=e.morphTargetInfluences)||void 0===t?void 0:t[this.index])&&(e.morphTargetInfluences[this.index]=0)}))}}const v=new n.Vector2;class g{constructor({material:e,scale:t,offset:i}){var n,r;this.material=e,this.scale=t,this.offset=i;const o=null===(n=Object.entries(g._propertyNamesMap).find((([t])=>!0===e[t])))||void 0===n?void 0:n[1];null==o?(console.warn(`Tried to add a texture transform bind to the material ${null!==(r=e.name)&&void 0!==r?r:"(no name)"} but the material is not supported.`),this._properties=[]):(this._properties=[],o.forEach((n=>{var r;const o=null===(r=e[n])||void 0===r?void 0:r.clone();if(!o)return null;e[n]=o;const s=o.offset.clone(),a=o.repeat.clone(),l=i.clone().sub(s),u=t.clone().sub(a);this._properties.push({name:n,initialOffset:s,deltaOffset:l,initialScale:a,deltaScale:u})})))}applyWeight(e){this._properties.forEach((t=>{const i=this.material[t.name];void 0!==i&&(i.offset.add(v.copy(t.deltaOffset).multiplyScalar(e)),i.repeat.add(v.copy(t.deltaScale).multiplyScalar(e)),i.needsUpdate=!0)}))}clearAppliedWeight(){this._properties.forEach((e=>{const t=this.material[e.name];void 0!==t&&(t.offset.copy(e.initialOffset),t.repeat.copy(e.initialScale),t.needsUpdate=!0)}))}}g._propertyNamesMap={isMeshStandardMaterial:["map","emissiveMap","bumpMap","normalMap","displacementMap","roughnessMap","metalnessMap","alphaMap"],isMeshBasicMaterial:["map","specularMap","alphaMap"],isMToonMaterial:["map","normalMap","emissiveMap","shadeMultiplyTexture","rimMultiplyTexture","outlineWidthMultiplyTexture","uvAnimationMaskTexture"]};class _{constructor(e){this.parser=e}get name(){return"VRMExpressionLoaderPlugin"}afterRoot(e){return o(this,void 0,void 0,(function*(){e.userData.vrmExpressionManager=yield this._import(e)}))}_import(e){return o(this,void 0,void 0,(function*(){const t=yield this._v1Import(e);if(t)return t;const i=yield this._v0Import(e);return i||null}))}_v1Import(e){var t,i;return o(this,void 0,void 0,(function*(){if(!(-1!==(null===(t=this.parser.json.extensionsUsed)||void 0===t?void 0:t.indexOf("VRMC_vrm"))))return null;const s=null===(i=this.parser.json.extensions)||void 0===i?void 0:i.VRMC_vrm;if(!s)return null;if("1.0-beta"!==s.specVersion)return null;const l=s.expressions;if(!l)return null;const h=new Set(Object.values(d)),p=new Map;null!=l.preset&&Object.entries(l.preset).forEach((([e,t])=>{null!=t&&(h.has(e)?p.set(e,t):console.warn(`VRMExpressionLoaderPlugin: Unknown preset name "${e}" detected. Ignoring the expression`))})),null!=l.custom&&Object.entries(l.custom).forEach((([e,t])=>{h.has(e)?console.warn(`VRMExpressionLoaderPlugin: Custom expression cannot have preset name "${e}". Ignoring the expression`):p.set(e,t)}));const v=new c;return yield Promise.all(Array.from(p.entries()).map((([t,i])=>o(this,void 0,void 0,(function*(){var s,l,d,h,c,p,_;const x=new r(t);if(e.scene.add(x),x.isBinary=null!==(s=i.isBinary)&&void 0!==s&&s,x.overrideBlink=null!==(l=i.overrideBlink)&&void 0!==l?l:"none",x.overrideLookAt=null!==(d=i.overrideLookAt)&&void 0!==d?d:"none",x.overrideMouth=null!==(h=i.overrideMouth)&&void 0!==h?h:"none",null===(c=i.morphTargetBinds)||void 0===c||c.forEach((t=>o(this,void 0,void 0,(function*(){var n;if(void 0===t.node||void 0===t.index)return;const r=yield a(e,t.node),o=t.index;r.every((e=>Array.isArray(e.morphTargetInfluences)&&o<e.morphTargetInfluences.length))?x.addBind(new f({primitives:r,index:o,weight:null!==(n=t.weight)&&void 0!==n?n:1})):console.warn(`VRMExpressionLoaderPlugin: ${i.name} attempts to index morph #${o} but not found.`)})))),i.materialColorBinds||i.textureTransformBinds){const t=[];e.scene.traverse((e=>{const i=e.material;i&&t.push(i)})),null===(p=i.materialColorBinds)||void 0===p||p.forEach((e=>o(this,void 0,void 0,(function*(){t.filter((t=>{const i=u(this.parser,t);return e.material===i})).forEach((t=>{x.addBind(new m({material:t,type:e.type,targetValue:(new n.Color).fromArray(e.targetValue)}))}))})))),null===(_=i.textureTransformBinds)||void 0===_||_.forEach((e=>o(this,void 0,void 0,(function*(){t.filter((t=>{const i=u(this.parser,t);return e.material===i})).forEach((t=>{var i,r;x.addBind(new g({material:t,offset:(new n.Vector2).fromArray(null!==(i=e.offset)&&void 0!==i?i:[0,0]),scale:(new n.Vector2).fromArray(null!==(r=e.scale)&&void 0!==r?r:[1,1])}))}))}))))}v.registerExpression(x)}))))),v}))}_v0Import(e){var t;return o(this,void 0,void 0,(function*(){const i=null===(t=this.parser.json.extensions)||void 0===t?void 0:t.VRM;if(!i)return null;const n=i.blendShapeMaster;if(!n)return null;const s=new c,l=n.blendShapeGroups;if(!l)return s;const u=new Set;return yield Promise.all(l.map((t=>o(this,void 0,void 0,(function*(){var i;const n=t.presetName,l=null!=n&&_.v0v1PresetNameMap[n]||null,d=null!=l?l:t.name;if(null==d)return void console.warn("VRMExpressionLoaderPlugin: One of custom expressions has no name. Ignoring the expression");if(u.has(d))return void console.warn(`VRMExpressionLoaderPlugin: An expression preset ${n} has duplicated entries. Ignoring the expression`);u.add(d);const h=new r(d);e.scene.add(h),h.isBinary=null!==(i=t.isBinary)&&void 0!==i&&i,t.binds&&t.binds.forEach((i=>o(this,void 0,void 0,(function*(){if(void 0===i.mesh||void 0===i.index)return;const n=[];this.parser.json.nodes.forEach(((e,t)=>{e.mesh===i.mesh&&n.push(t)}));const r=i.index;yield Promise.all(n.map((n=>o(this,void 0,void 0,(function*(){var o;const s=yield a(e,n);s.every((e=>Array.isArray(e.morphTargetInfluences)&&r<e.morphTargetInfluences.length))?h.addBind(new f({primitives:s,index:r,weight:.01*(null!==(o=i.weight)&&void 0!==o?o:100)})):console.warn(`VRMExpressionLoaderPlugin: ${t.name} attempts to index ${r}th morph but not found.`)})))))}))));const c=t.materialValues;c&&0!==c.length&&console.warn("Material binds of VRM 0.0 are not supported. Setup the model in VRM 1.0 and try again"),s.registerExpression(h)}))))),s}))}}_.v0v1PresetNameMap={a:"aa",e:"ee",i:"ih",o:"oh",u:"ou",blink:"blink",joy:"happy",angry:"angry",sorrow:"sad",fun:"relaxed",lookup:"lookUp",lookdown:"lookDown",lookleft:"lookLeft",lookright:"lookRight",blink_l:"blinkLeft",blink_r:"blinkRight",neutral:"neutral"};class x{constructor(e,t){this._firstPersonOnlyLayer=x.DEFAULT_FIRSTPERSON_ONLY_LAYER,this._thirdPersonOnlyLayer=x.DEFAULT_THIRDPERSON_ONLY_LAYER,this._initializedLayers=!1,this.humanoid=e,this.meshAnnotations=t}copy(e){if(this.humanoid!==e.humanoid)throw new Error("VRMFirstPerson: humanoid must be same in order to copy");return this.meshAnnotations=e.meshAnnotations.map((e=>({meshes:e.meshes.concat(),type:e.type}))),this}clone(){return new x(this.humanoid,this.meshAnnotations).copy(this)}get firstPersonOnlyLayer(){return this._firstPersonOnlyLayer}get thirdPersonOnlyLayer(){return this._thirdPersonOnlyLayer}setup({firstPersonOnlyLayer:e=x.DEFAULT_FIRSTPERSON_ONLY_LAYER,thirdPersonOnlyLayer:t=x.DEFAULT_THIRDPERSON_ONLY_LAYER}={}){this._initializedLayers||(this._firstPersonOnlyLayer=e,this._thirdPersonOnlyLayer=t,this.meshAnnotations.forEach((e=>{e.meshes.forEach((t=>{"firstPersonOnly"===e.type?(t.layers.set(this._firstPersonOnlyLayer),t.traverse((e=>e.layers.set(this._firstPersonOnlyLayer)))):"thirdPersonOnly"===e.type?(t.layers.set(this._thirdPersonOnlyLayer),t.traverse((e=>e.layers.set(this._thirdPersonOnlyLayer)))):"auto"===e.type&&this._createHeadlessModel(t)}))})),this._initializedLayers=!0)}_excludeTriangles(e,t,i,n){let r=0;if(null!=t&&t.length>0)for(let o=0;o<e.length;o+=3){const s=e[o],a=e[o+1],l=e[o+2],u=t[s],d=i[s];if(u[0]>0&&n.includes(d[0]))continue;if(u[1]>0&&n.includes(d[1]))continue;if(u[2]>0&&n.includes(d[2]))continue;if(u[3]>0&&n.includes(d[3]))continue;const h=t[a],c=i[a];if(h[0]>0&&n.includes(c[0]))continue;if(h[1]>0&&n.includes(c[1]))continue;if(h[2]>0&&n.includes(c[2]))continue;if(h[3]>0&&n.includes(c[3]))continue;const p=t[l],m=i[l];p[0]>0&&n.includes(m[0])||(p[1]>0&&n.includes(m[1])||p[2]>0&&n.includes(m[2])||p[3]>0&&n.includes(m[3])||(e[r++]=s,e[r++]=a,e[r++]=l))}return r}_createErasedMesh(e,t){const i=new n.SkinnedMesh(e.geometry.clone(),e.material);i.name=`${e.name}(erase)`,i.frustumCulled=e.frustumCulled,i.layers.set(this._firstPersonOnlyLayer);const r=i.geometry,o=r.getAttribute("skinIndex").array,s=[];for(let e=0;e<o.length;e+=4)s.push([o[e],o[e+1],o[e+2],o[e+3]]);const a=r.getAttribute("skinWeight").array,l=[];for(let e=0;e<a.length;e+=4)l.push([a[e],a[e+1],a[e+2],a[e+3]]);const u=r.getIndex();if(!u)throw new Error("The geometry doesn't have an index buffer");const d=Array.from(u.array),h=this._excludeTriangles(d,l,s,t),c=[];for(let e=0;e<h;e++)c[e]=d[e];return r.setIndex(c),e.onBeforeRender&&(i.onBeforeRender=e.onBeforeRender),i.bind(new n.Skeleton(e.skeleton.bones,e.skeleton.boneInverses),new n.Matrix4),i}_createHeadlessModelForSkinnedMesh(e,t){const i=[];if(t.skeleton.bones.forEach(((e,t)=>{this._isEraseTarget(e)&&i.push(t)})),!i.length)return t.layers.enable(this._thirdPersonOnlyLayer),void t.layers.enable(this._firstPersonOnlyLayer);t.layers.set(this._thirdPersonOnlyLayer);const n=this._createErasedMesh(t,i);e.add(n)}_createHeadlessModel(e){if("Group"===e.type)if(e.layers.set(this._thirdPersonOnlyLayer),this._isEraseTarget(e))e.traverse((e=>e.layers.set(this._thirdPersonOnlyLayer)));else{const t=new n.Group;t.name=`_headless_${e.name}`,t.layers.set(this._firstPersonOnlyLayer),e.parent.add(t),e.children.filter((e=>"SkinnedMesh"===e.type)).forEach((e=>{const i=e;this._createHeadlessModelForSkinnedMesh(t,i)}))}else if("SkinnedMesh"===e.type){const t=e;this._createHeadlessModelForSkinnedMesh(e.parent,t)}else this._isEraseTarget(e)&&(e.layers.set(this._thirdPersonOnlyLayer),e.traverse((e=>e.layers.set(this._thirdPersonOnlyLayer))))}_isEraseTarget(e){return e===this.humanoid.getBoneNode("head")||!!e.parent&&this._isEraseTarget(e.parent)}}x.DEFAULT_FIRSTPERSON_ONLY_LAYER=9,x.DEFAULT_THIRDPERSON_ONLY_LAYER=10;class M{constructor(e){this.parser=e}get name(){return"VRMFirstPersonLoaderPlugin"}afterRoot(e){return o(this,void 0,void 0,(function*(){const t=e.userData.vrmHumanoid;if(null!==t){if(void 0===t)throw new Error("VRMFirstPersonLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first");e.userData.vrmFirstPerson=yield this._import(e,t)}}))}_import(e,t){return o(this,void 0,void 0,(function*(){if(null==t)return null;const i=yield this._v1Import(e,t);if(i)return i;const n=yield this._v0Import(e,t);return n||null}))}_v1Import(e,t){var i,n;return o(this,void 0,void 0,(function*(){if(!(-1!==(null===(i=this.parser.json.extensionsUsed)||void 0===i?void 0:i.indexOf("VRMC_vrm"))))return null;const r=null===(n=this.parser.json.extensions)||void 0===n?void 0:n.VRMC_vrm;if(!r)return null;if("1.0-beta"!==r.specVersion)return null;const o=r.firstPerson;if(!o)return null;const s=[],a=yield l(e);return Array.from(a.entries()).forEach((([e,t])=>{var i;const n=o.meshAnnotations?o.meshAnnotations.find((t=>t.node===e)):void 0;s.push({meshes:t,type:null!==(i=null==n?void 0:n.type)&&void 0!==i?i:"both"})})),new x(t,s)}))}_v0Import(e,t){var i;return o(this,void 0,void 0,(function*(){const n=null===(i=this.parser.json.extensions)||void 0===i?void 0:i.VRM;if(!n)return null;const r=n.firstPerson;if(!r)return null;const o=[],s=yield l(e);return Array.from(s.entries()).forEach((([e,t])=>{const i=this.parser.json.nodes[e],n=r.meshAnnotations?r.meshAnnotations.find((e=>e.mesh===i.mesh)):void 0;o.push({meshes:t,type:this._convertV0FlagToV1Type(null==n?void 0:n.firstPersonFlag)})})),new x(t,o)}))}_convertV0FlagToV1Type(e){return"FirstPersonOnly"===e?"firstPersonOnly":"ThirdPersonOnly"===e?"thirdPersonOnly":"Auto"===e?"auto":"both"}}function y(e){return e.invert?e.invert():e.inverse(),e}const T=new n.Vector3,S=new n.Quaternion;class R{constructor(e){this.humanBones=e,this.restPose=this.getAbsolutePose()}copy(e){return this.humanBones=e.humanBones,this.restPose=e.restPose,this}clone(){return new R(this.humanBones).copy(this)}getAbsolutePose(){const e={};return Object.keys(this.humanBones).forEach((t=>{const i=t,n=this.getBoneNode(i);n&&(T.copy(n.position),S.copy(n.quaternion),e[i]={position:T.toArray(),rotation:S.toArray()})})),e}getPose(){const e={};return Object.keys(this.humanBones).forEach((t=>{const i=t,n=this.getBoneNode(i);if(!n)return;T.set(0,0,0),S.identity();const r=this.restPose[i];(null==r?void 0:r.position)&&T.fromArray(r.position).negate(),(null==r?void 0:r.rotation)&&y(S.fromArray(r.rotation)),T.add(n.position),S.premultiply(n.quaternion),e[i]={position:T.toArray(),rotation:S.toArray()}})),e}setPose(e){Object.entries(e).forEach((([e,t])=>{const i=e,n=this.getBoneNode(i);if(!n)return;const r=this.restPose[i];r&&((null==t?void 0:t.position)&&(n.position.fromArray(t.position),r.position&&n.position.add(T.fromArray(r.position))),(null==t?void 0:t.rotation)&&(n.quaternion.fromArray(t.rotation),r.rotation&&n.quaternion.multiply(S.fromArray(r.rotation))))}))}resetPose(){Object.entries(this.restPose).forEach((([e,t])=>{const i=this.getBoneNode(e);i&&((null==t?void 0:t.position)&&i.position.fromArray(t.position),(null==t?void 0:t.rotation)&&i.quaternion.fromArray(t.rotation))}))}getBone(e){var t;return null!==(t=this.humanBones[e])&&void 0!==t?t:void 0}getBoneNode(e){var t,i;return null!==(i=null===(t=this.humanBones[e])||void 0===t?void 0:t.node)&&void 0!==i?i:null}}const w={Hips:"hips",Spine:"spine",Head:"head",LeftUpperLeg:"leftUpperLeg",LeftLowerLeg:"leftLowerLeg",LeftFoot:"leftFoot",RightUpperLeg:"rightUpperLeg",RightLowerLeg:"rightLowerLeg",RightFoot:"rightFoot",LeftUpperArm:"leftUpperArm",LeftLowerArm:"leftLowerArm",LeftHand:"leftHand",RightUpperArm:"rightUpperArm",RightLowerArm:"rightLowerArm",RightHand:"rightHand"};class P{constructor(e){this.parser=e}get name(){return"VRMHumanoidLoaderPlugin"}afterRoot(e){return o(this,void 0,void 0,(function*(){e.userData.vrmHumanoid=yield this._import(e)}))}_import(e){return o(this,void 0,void 0,(function*(){const t=yield this._v1Import(e);if(t)return t;const i=yield this._v0Import(e);return i||null}))}_v1Import(e){var t,i;return o(this,void 0,void 0,(function*(){if(!(-1!==(null===(t=this.parser.json.extensionsUsed)||void 0===t?void 0:t.indexOf("VRMC_vrm"))))return null;const e=null===(i=this.parser.json.extensions)||void 0===i?void 0:i.VRMC_vrm;if(!e)return null;if("1.0-beta"!==e.specVersion)return null;const n=e.humanoid;if(!n)return null;const r={};return null!=n.humanBones&&(yield Promise.all(Object.entries(n.humanBones).map((([e,t])=>o(this,void 0,void 0,(function*(){const i=e,n=t.node,o=yield this.parser.getDependency("node",n);null!=o?r[i]={node:o}:console.warn(`A glTF node bound to the humanoid bone ${i} (index = ${n}) does not exist`)})))))),new R(this._ensureRequiredBonesExist(r))}))}_v0Import(e){var t;return o(this,void 0,void 0,(function*(){const e=null===(t=this.parser.json.extensions)||void 0===t?void 0:t.VRM;if(!e)return null;const i=e.humanoid;if(!i)return null;const n={};return null!=i.humanBones&&(yield Promise.all(i.humanBones.map((e=>o(this,void 0,void 0,(function*(){const t=e.bone,i=e.node;if(null==t||null==i)return;const r=yield this.parser.getDependency("node",i);null!=r?null==n[t]?n[t]={node:r}:console.warn(`Multiple bone entries for ${t} detected (index = ${i}), ignoring duplicated entries.`):console.warn(`A glTF node bound to the humanoid bone ${t} (index = ${i}) does not exist`)})))))),new R(this._ensureRequiredBonesExist(n))}))}_ensureRequiredBonesExist(e){const t=Object.values(w).filter((t=>null==e[t]));if(t.length>0)throw new Error(`VRMHumanoidLoaderPlugin: These humanoid bones are required but not exist: ${t.join(", ")}`);return e}}class E extends n.BufferGeometry{constructor(){super(),this._currentTheta=0,this._currentRadius=0,this.theta=0,this.radius=0,this._currentTheta=0,this._currentRadius=0,this._attrPos=new n.BufferAttribute(new Float32Array(195),3),this.setAttribute("position",this._attrPos),this._attrIndex=new n.BufferAttribute(new Uint16Array(189),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let e=!1;this._currentTheta!==this.theta&&(this._currentTheta=this.theta,e=!0),this._currentRadius!==this.radius&&(this._currentRadius=this.radius,e=!0),e&&this._buildPosition()}_buildPosition(){this._attrPos.setXYZ(0,0,0,0);for(let e=0;e<64;e++){const t=e/63*this._currentTheta;this._attrPos.setXYZ(e+1,this._currentRadius*Math.sin(t),0,this._currentRadius*Math.cos(t))}this._attrPos.needsUpdate=!0}_buildIndex(){for(let e=0;e<63;e++)this._attrIndex.setXYZ(3*e,0,e+1,e+2);this._attrIndex.needsUpdate=!0}}class L extends n.BufferGeometry{constructor(){super(),this.radius=0,this._currentRadius=0,this.tail=new n.Vector3,this._currentTail=new n.Vector3,this._attrPos=new n.BufferAttribute(new Float32Array(294),3),this.setAttribute("position",this._attrPos),this._attrIndex=new n.BufferAttribute(new Uint16Array(194),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let e=!1;this._currentRadius!==this.radius&&(this._currentRadius=this.radius,e=!0),this._currentTail.equals(this.tail)||(this._currentTail.copy(this.tail),e=!0),e&&this._buildPosition()}_buildPosition(){for(let e=0;e<32;e++){const t=e/16*Math.PI;this._attrPos.setXYZ(e,Math.cos(t),Math.sin(t),0),this._attrPos.setXYZ(32+e,0,Math.cos(t),Math.sin(t)),this._attrPos.setXYZ(64+e,Math.sin(t),0,Math.cos(t))}this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.setXYZ(96,0,0,0),this._attrPos.setXYZ(97,this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let e=0;e<32;e++){const t=(e+1)%32;this._attrIndex.setXY(2*e,e,t),this._attrIndex.setXY(64+2*e,32+e,32+t),this._attrIndex.setXY(128+2*e,64+e,64+t)}this._attrIndex.setXY(192,96,97),this._attrIndex.needsUpdate=!0}}const A=new n.Quaternion,b=new n.Quaternion,I=new n.Vector3,O=new n.Vector3,U=Math.sqrt(2)/2,V=new n.Quaternion(0,0,-U,U),C=new n.Vector3(0,1,0);class N extends n.Group{constructor(e){super(),this.matrixAutoUpdate=!1,this.vrmLookAt=e;{const e=new E;e.radius=.5;const t=new n.MeshBasicMaterial({color:65280,transparent:!0,opacity:.5,side:n.DoubleSide,depthTest:!1,depthWrite:!1});this._meshPitch=new n.Mesh(e,t),this.add(this._meshPitch)}{const e=new E;e.radius=.5;const t=new n.MeshBasicMaterial({color:16711680,transparent:!0,opacity:.5,side:n.DoubleSide,depthTest:!1,depthWrite:!1});this._meshYaw=new n.Mesh(e,t),this.add(this._meshYaw)}{const e=new L;e.radius=.1;const t=new n.LineBasicMaterial({color:16777215,depthTest:!1,depthWrite:!1});this._lineTarget=new n.LineSegments(e,t),this._lineTarget.frustumCulled=!1,this.add(this._lineTarget)}}dispose(){this._meshYaw.geometry.dispose(),this._meshYaw.material.dispose(),this._meshPitch.geometry.dispose(),this._meshPitch.material.dispose(),this._lineTarget.geometry.dispose(),this._lineTarget.material.dispose()}updateMatrixWorld(e){this.vrmLookAt.getLookAtWorldPosition(I),this.vrmLookAt.getLookAtWorldQuaternion(A);const t=this.vrmLookAt.euler.y,i=this.vrmLookAt.euler.x;this._meshYaw.geometry.theta=t,this._meshYaw.geometry.update(),this._meshYaw.position.copy(I),this._meshYaw.quaternion.copy(A),this._meshPitch.geometry.theta=i,this._meshPitch.geometry.update(),this._meshPitch.position.copy(I),this._meshPitch.quaternion.copy(A),this._meshPitch.quaternion.multiply(b.setFromAxisAngle(C,t)),this._meshPitch.quaternion.multiply(V);const n=this.vrmLookAt.target;null!=n&&(n.getWorldPosition(O).sub(I),this._lineTarget.geometry.tail.copy(O),this._lineTarget.geometry.update(),this._lineTarget.position.copy(I)),super.updateMatrixWorld(e)}}const F=new n.Vector3,D=new n.Vector3;const B=new n.Vector3,k=new n.Vector3,W=new n.Vector3,H=new n.Quaternion,j=new n.Quaternion;class z{constructor(e,t){this.offsetFromHeadBone=new n.Vector3,this.autoUpdate=!0,this.faceFront=new n.Vector3(0,0,1),this._euler=new n.Euler(0,0,0,z.EULER_ORDER),this.humanoid=e,this.applier=t}get euler(){return this._euler.clone()}copy(e){if(this.humanoid!==e.humanoid)throw new Error("VRMLookAt: humanoid must be same in order to copy");return this.offsetFromHeadBone.copy(e.offsetFromHeadBone),this.applier=e.applier,this.autoUpdate=e.autoUpdate,this.target=e.target,this.faceFront.copy(e.faceFront),this}clone(){return new z(this.humanoid,this.applier).copy(this)}reset(){this._euler.set(0,0,0),this.applier.lookAt(this._euler)}getLookAtWorldPosition(e){const t=this.humanoid.getBoneNode("head");return e.copy(this.offsetFromHeadBone).applyMatrix4(t.matrixWorld)}getLookAtWorldQuaternion(e){const t=this.humanoid.getBoneNode("head");return i=e,t.matrixWorld.decompose(F,i,D),i;var i}getLookAtWorldDirection(e){return this.getLookAtWorldQuaternion(H),e.copy(this.faceFront).applyEuler(this._euler).applyQuaternion(H)}lookAt(e){this._calcEuler(this._euler,e),this.applier.lookAt(this._euler)}update(e){this.target&&this.autoUpdate&&(this.lookAt(this.target.getWorldPosition(B)),this.applier.lookAt(this._euler))}_calcEuler(e,t){const i=y(this.getLookAtWorldQuaternion(H)),n=this.getLookAtWorldPosition(k),r=W.copy(t).sub(n).applyQuaternion(i).normalize(),o=j.setFromUnitVectors(this.faceFront,r);return W.set(0,0,1).applyQuaternion(o),e.x=Math.atan2(-W.y,Math.sqrt(W.x*W.x+W.z*W.z)),e.y=Math.atan2(W.x,W.z),e}}z.EULER_ORDER="YXZ";const X=new n.Euler(0,0,0,"YXZ");class Y{constructor(e,t,i,n,r){this.humanoid=e,this.rangeMapHorizontalInner=t,this.rangeMapHorizontalOuter=i,this.rangeMapVerticalDown=n,this.rangeMapVerticalUp=r}lookAt(e){const t=180*e.x/Math.PI,i=180*e.y/Math.PI,n=this.humanoid.getBoneNode("leftEye"),r=this.humanoid.getBoneNode("rightEye");n&&(X.x=t<0?-this.rangeMapVerticalDown.map(-t)/180*Math.PI:this.rangeMapVerticalUp.map(t)/180*Math.PI,X.y=i<0?-this.rangeMapHorizontalInner.map(-i)/180*Math.PI:this.rangeMapHorizontalOuter.map(i)/180*Math.PI,n.quaternion.setFromEuler(X)),r&&(X.x=t<0?-this.rangeMapVerticalDown.map(-t)/180*Math.PI:this.rangeMapVerticalUp.map(t)/180*Math.PI,X.y=i<0?-this.rangeMapHorizontalOuter.map(-i)/180*Math.PI:this.rangeMapHorizontalInner.map(i)/180*Math.PI,r.quaternion.setFromEuler(X))}}Y.type="bone";class G{constructor(e,t,i,n,r){this.expressions=e,this.rangeMapHorizontalInner=t,this.rangeMapHorizontalOuter=i,this.rangeMapVerticalDown=n,this.rangeMapVerticalUp=r}lookAt(e){const t=180*e.x/Math.PI,i=180*e.y/Math.PI;t<0?(this.expressions.setValue("lookDown",0),this.expressions.setValue("lookUp",this.rangeMapVerticalUp.map(-t))):(this.expressions.setValue("lookUp",0),this.expressions.setValue("lookDown",this.rangeMapVerticalDown.map(t))),i<0?(this.expressions.setValue("lookLeft",0),this.expressions.setValue("lookRight",this.rangeMapHorizontalOuter.map(-i))):(this.expressions.setValue("lookRight",0),this.expressions.setValue("lookLeft",this.rangeMapHorizontalOuter.map(i)))}}G.type="expression";class q{constructor(e,t){this.inputMaxValue=e,this.outputScale=t}map(e){return this.outputScale*h(e/this.inputMaxValue)}}class Q{constructor(e,t){this.parser=e,this.helperRoot=null==t?void 0:t.helperRoot}get name(){return"VRMLookAtLoaderPlugin"}afterRoot(e){return o(this,void 0,void 0,(function*(){const t=e.userData.vrmHumanoid;if(null===t)return;if(void 0===t)throw new Error("VRMFirstPersonLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first");const i=e.userData.vrmExpressionManager;if(null!==i){if(void 0===i)throw new Error("VRMFirstPersonLoaderPlugin: vrmExpressionManager is undefined. VRMExpressionLoaderPlugin have to be used first");e.userData.vrmLookAt=yield this._import(e,t,i)}}))}_import(e,t,i){return o(this,void 0,void 0,(function*(){if(null==t||null==i)return null;const n=yield this._v1Import(e,t,i);if(n)return n;const r=yield this._v0Import(e,t,i);return r||null}))}_v1Import(e,t,i){var n,r,s;return o(this,void 0,void 0,(function*(){if(!(-1!==(null===(n=this.parser.json.extensionsUsed)||void 0===n?void 0:n.indexOf("VRMC_vrm"))))return null;const e=null===(r=this.parser.json.extensions)||void 0===r?void 0:r.VRMC_vrm;if(!e)return null;if("1.0-beta"!==e.specVersion)return null;const o=e.lookAt;if(!o)return null;const a="expression"===o.type?1:10,l=this._v1ImportRangeMap(o.rangeMapHorizontalInner,a),u=this._v1ImportRangeMap(o.rangeMapHorizontalOuter,a),d=this._v1ImportRangeMap(o.rangeMapVerticalDown,a),h=this._v1ImportRangeMap(o.rangeMapVerticalUp,a);let c;c="expression"===o.type?new G(i,l,u,d,h):new Y(t,l,u,d,h);const p=this._importLookAt(t,c);return p.offsetFromHeadBone.fromArray(null!==(s=o.offsetFromHeadBone)&&void 0!==s?s:[0,.06,0]),p}))}_v1ImportRangeMap(e,t){var i,n;return new q(null!==(i=null==e?void 0:e.inputMaxValue)&&void 0!==i?i:90,null!==(n=null==e?void 0:e.outputScale)&&void 0!==n?n:t)}_v0Import(e,t,i){var n,r,s,a;return o(this,void 0,void 0,(function*(){const e=null===(n=this.parser.json.extensions)||void 0===n?void 0:n.VRM;if(!e)return null;const o=e.firstPerson;if(!o)return null;const l="BlendShape"===o.lookAtTypeName?1:10,u=this._v0ImportDegreeMap(o.lookAtHorizontalInner,l),d=this._v0ImportDegreeMap(o.lookAtHorizontalOuter,l),h=this._v0ImportDegreeMap(o.lookAtVerticalDown,l),c=this._v0ImportDegreeMap(o.lookAtVerticalUp,l);let p;p="BlendShape"===o.lookAtTypeName?new G(i,u,d,h,c):new Y(t,u,d,h,c);const m=this._importLookAt(t,p);return o.firstPersonBoneOffset?m.offsetFromHeadBone.set(null!==(r=o.firstPersonBoneOffset.x)&&void 0!==r?r:0,null!==(s=o.firstPersonBoneOffset.y)&&void 0!==s?s:.06,-(null!==(a=o.firstPersonBoneOffset.z)&&void 0!==a?a:0)):m.offsetFromHeadBone.set(0,.06,0),m.faceFront.set(0,0,-1),m}))}_v0ImportDegreeMap(e,t){var i,n;const r=null==e?void 0:e.curve;return"[0,0,0,1,1,1,1,0]"!==JSON.stringify(r)&&console.warn("Curves of LookAtDegreeMap defined in VRM 0.0 are not supported"),new q(null!==(i=null==e?void 0:e.xRange)&&void 0!==i?i:90,null!==(n=null==e?void 0:e.yRange)&&void 0!==n?n:t)}_importLookAt(e,t){const i=new z(e,t);if(this.helperRoot){const e=new N(i);this.helperRoot.add(e),e.renderOrder=this.helperRoot.renderOrder}return i}}class ${constructor(e,t){var i,n,r;this.parser=e,this.needThumbnailImage=null===(i=null==t?void 0:t.needThumbnailImage)||void 0===i||i,this.acceptLicenseUrls=null!==(n=null==t?void 0:t.acceptLicenseUrls)&&void 0!==n?n:["https://vrm.dev/licenses/1.0/"],this.acceptV0Meta=null===(r=null==t?void 0:t.acceptV0Meta)||void 0===r||r}get name(){return"VRMMetaLoaderPlugin"}afterRoot(e){return o(this,void 0,void 0,(function*(){e.userData.vrmMeta=yield this._import(e)}))}_import(e){return o(this,void 0,void 0,(function*(){const t=yield this._v1Import(e);if(null!=t)return t;const i=yield this._v0Import(e);return null!=i?i:null}))}_v1Import(e){var t,i,n;return o(this,void 0,void 0,(function*(){if(!(-1!==(null===(t=this.parser.json.extensionsUsed)||void 0===t?void 0:t.indexOf("VRMC_vrm"))))return null;const e=null===(i=this.parser.json.extensions)||void 0===i?void 0:i.VRMC_vrm;if(null==e)return null;if("1.0-beta"!==e.specVersion)return null;const r=e.meta;if(!r)return null;const o=r.licenseUrl;if(!new Set(this.acceptLicenseUrls).has(o))throw new Error(`VRMMetaLoaderPlugin: The license url "${o}" is not accepted`);let s;return this.needThumbnailImage&&null!=r.thumbnailImage&&(s=null!==(n=yield this._extractGLTFImage(r.thumbnailImage))&&void 0!==n?n:void 0),{metaVersion:"1",name:r.name,version:r.version,authors:r.authors,copyrightInformation:r.copyrightInformation,contactInformation:r.contactInformation,references:r.references,thirdPartyLicenses:r.thirdPartyLicenses,thumbnailImage:s,licenseUrl:r.licenseUrl,avatarPermission:r.avatarPermission,allowExcessivelyViolentUsage:r.allowExcessivelyViolentUsage,allowExcessivelySexualUsage:r.allowExcessivelySexualUsage,commercialUsage:r.commercialUsage,allowPoliticalOrReligiousUsage:r.allowPoliticalOrReligiousUsage,allowAntisocialOrHateUsage:r.allowAntisocialOrHateUsage,creditNotation:r.creditNotation,allowRedistribution:r.allowRedistribution,modification:r.modification,otherLicenseUrl:r.otherLicenseUrl}}))}_v0Import(e){var t;return o(this,void 0,void 0,(function*(){const e=null===(t=this.parser.json.extensions)||void 0===t?void 0:t.VRM;if(!e)return null;const i=e.meta;if(!i)return null;if(!this.acceptV0Meta)throw new Error("VRMMetaLoaderPlugin: Attempted to load VRM0.X meta but acceptV0Meta is false");let n;return this.needThumbnailImage&&null!=i.texture&&-1!==i.texture&&(n=yield this.parser.getDependency("texture",i.texture)),{metaVersion:"0",allowedUserName:i.allowedUserName,author:i.author,commercialUssageName:i.commercialUssageName,contactInformation:i.contactInformation,licenseName:i.licenseName,otherLicenseUrl:i.otherLicenseUrl,otherPermissionUrl:i.otherPermissionUrl,reference:i.reference,sexualUssageName:i.sexualUssageName,texture:null!=n?n:void 0,title:i.title,version:i.version,violentUssageName:i.violentUssageName}}))}_extractGLTFImage(e){var t;return o(this,void 0,void 0,(function*(){const i=null===(t=this.parser.json.images)||void 0===t?void 0:t[e];if(null==i)return console.warn(`Attempt to use images[${e}] of glTF as a thumbnail but the image doesn't exist`),null;let r=i.uri;if(null!=i.bufferView){const e=yield this.parser.getDependency("bufferView",i.bufferView),t=new Blob([e],{type:i.mimeType});r=URL.createObjectURL(t)}if(null==r)return console.warn(`Attempt to use images[${e}] of glTF as a thumbnail but the image couldn't load properly`),null;const o=new n.ImageLoader;return yield o.loadAsync((s=r,a=this.parser.options.path,"string"!=typeof s||""===s?"":(/^https?:\/\//i.test(a)&&/^\//.test(s)&&(a=a.replace(/(^https?:\/\/[^/]+).*/i,"$1")),/^(https?:)?\/\//i.test(s)||/^data:.*,.*$/i.test(s)||/^blob:.*$/i.test(s)?s:a+s))).catch((e=>(console.error(e),console.warn("Failed to load a thumbnail image"),null)));var s,a}))}}class Z{constructor(e){this.scene=e.scene,this.humanoid=e.humanoid,this.expressionManager=e.expressionManager,this.firstPerson=e.firstPerson,this.lookAt=e.lookAt,this.meta=e.meta}update(e){this.lookAt&&this.lookAt.update(e),this.expressionManager&&this.expressionManager.update()}}class K extends Z{constructor(e){super(e),this.materials=e.materials,this.springBoneManager=e.springBoneManager,this.constraintManager=e.constraintManager}update(e){super.update(e),this.constraintManager&&this.constraintManager.update(),this.springBoneManager&&this.springBoneManager.update(e),this.materials&&this.materials.forEach((t=>{t.update&&t.update(e)}))}}
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */function J(e,t,i,n){return new(i||(i=Promise))((function(r,o){function s(e){try{l(n.next(e))}catch(e){o(e)}}function a(e){try{l(n.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?r(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(s,a)}l((n=n.apply(e,t||[])).next())}))}
/*!
     * @pixiv/three-vrm-materials-mtoon v1.0.0-beta.7
     * MToon (toon material) module for @pixiv/three-vrm
     *
     * Copyright (c) 2020-2021 pixiv Inc.
     * @pixiv/three-vrm-materials-mtoon is distributed under MIT License
     * https://github.com/pixiv/three-vrm/blob/release/LICENSE
     */
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */function ee(e,t,i,n){return new(i||(i=Promise))((function(r,o){function s(e){try{l(n.next(e))}catch(e){o(e)}}function a(e){try{l(n.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?r(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(s,a)}l((n=n.apply(e,t||[])).next())}))}const te=(e,t)=>{const i=(e=>{switch(e){case n.LinearEncoding:return["Linear","( value )"];case n.sRGBEncoding:return["sRGB","( value )"];case n.RGBEEncoding:return["RGBE","( value )"];case n.RGBM7Encoding:return["RGBM","( value, 7.0 )"];case n.RGBM16Encoding:return["RGBM","( value, 16.0 )"];case n.RGBDEncoding:return["RGBD","( value, 256.0 )"];case n.GammaEncoding:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case n.LogLuvEncoding:return["LogLuv","( value )"];default:throw new Error("unsupported encoding: "+e)}})(t);return"vec4 "+e+"( vec4 value ) { return "+i[0]+"ToLinear"+i[1]+"; }"};const ie={None:"none",Normal:"normal",LitShadeRate:"litShadeRate",UV:"uv"},ne={None:"none",WorldCoordinates:"worldCoordinates",ScreenCoordinates:"screenCoordinates"};function re(e,t){let i;return i=e&&e.isTexture?e.encoding:n.LinearEncoding,parseInt(n.REVISION,10)>=133&&t&&e&&e.isTexture&&e.format===n.RGBAFormat&&e.type===n.UnsignedByteType&&e.encoding===n.sRGBEncoding&&(i=n.LinearEncoding),i}class oe extends n.ShaderMaterial{constructor(e={}){super({vertexShader:"// #define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n\n#include <common>\n\n// #include <uv_pars_vertex>\n#ifdef MTOON_USE_UV\n  varying vec2 vUv;\n  uniform mat3 uvTransform;\n#endif\n\n#include <uv2_pars_vertex>\n// #include <displacementmap_pars_vertex>\n// #include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE\n  uniform sampler2D outlineWidthMultiplyTexture;\n  uniform mat3 outlineWidthMultiplyTextureUvTransform;\n#endif\n\nuniform float outlineWidthFactor;\n\nvoid main() {\n\n  // #include <uv_vertex>\n  #ifdef MTOON_USE_UV\n    vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n  #endif\n\n  #include <uv2_vertex>\n  #include <color_vertex>\n\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n\n  // we need this to compute the outline properly\n  objectNormal = normalize( objectNormal );\n\n  #include <defaultnormal_vertex>\n\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n    vNormal = normalize( transformedNormal );\n  #endif\n\n  #include <begin_vertex>\n\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  // #include <displacementmap_vertex>\n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n\n  vViewPosition = - mvPosition.xyz;\n\n  float outlineTex = 1.0;\n\n  #ifdef OUTLINE\n    #ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE\n      vec2 outlineWidthMultiplyTextureUv = ( outlineWidthMultiplyTextureUvTransform * vec3( vUv, 1 ) ).xy;\n      outlineTex = texture2D( outlineWidthMultiplyTexture, outlineWidthMultiplyTextureUv ).g;\n    #endif\n\n    #ifdef OUTLINE_WIDTH_WORLD\n      float worldNormalLength = length( transformedNormal );\n      vec3 outlineOffset = outlineWidthFactor * outlineTex * worldNormalLength * objectNormal;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( outlineOffset + transformed, 1.0 );\n    #endif\n\n    #ifdef OUTLINE_WIDTH_SCREEN\n      vec3 clipNormal = ( projectionMatrix * modelViewMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n      vec2 projectedNormal = normalize( clipNormal.xy );\n      projectedNormal.x *= projectionMatrix[ 0 ].x / projectionMatrix[ 1 ].y;\n      gl_Position.xy += 2.0 * outlineWidthFactor * outlineTex * projectedNormal.xy;\n    #endif\n\n    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic\n  #endif\n\n  #include <worldpos_vertex>\n  // #include <envmap_vertex>\n  #include <shadowmap_vertex>\n  #include <fog_vertex>\n\n}",fragmentShader:'// #define PHONG\n\nuniform vec3 litFactor;\n\nuniform float opacity;\n\nuniform vec3 shadeColorFactor;\n#ifdef USE_SHADEMULTIPLYTEXTURE\n  uniform sampler2D shadeMultiplyTexture;\n#endif\n\nuniform float shadingShiftFactor;\nuniform float shadingToonyFactor;\n\n#ifdef USE_SHADINGSHIFTTEXTURE\n  uniform sampler2D shadingShiftTexture;\n  uniform mat3 shadingShiftTextureUvTransform;\n  uniform float shadingShiftTextureScale;\n#endif\n\nuniform float giEqualizationFactor;\n\nuniform vec3 parametricRimColorFactor;\n#ifdef USE_RIMMULTIPLYTEXTURE\n  uniform sampler2D rimMultiplyTexture;\n  uniform mat3 rimMultiplyTextureUvTransform;\n#endif\nuniform float rimLightingMixFactor;\nuniform float parametricRimFresnelPowerFactor;\nuniform float parametricRimLiftFactor;\n\n#ifdef USE_MATCAPTEXTURE\n  uniform vec3 matcapFactor;\n  uniform sampler2D matcapTexture;\n  uniform mat3 matcapTextureUvTransform;\n#endif\n\nuniform vec3 emissive;\n\nuniform vec3 outlineColorFactor;\nuniform float outlineLightingMixFactor;\n\n#ifdef USE_UVANIMATIONMASKTEXTURE\n  uniform sampler2D uvAnimationMaskTexture;\n  uniform mat3 uvAnimationMaskTextureUvTransform;\n#endif\n\nuniform float uvAnimationScrollXOffset;\nuniform float uvAnimationScrollYOffset;\nuniform float uvAnimationRotationPhase;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n\n// #include <uv_pars_fragment>\n#if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n  varying vec2 vUv;\n#endif\n\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n\n#ifdef USE_MAP\n  uniform mat3 mapUvTransform;\n#endif\n\n// #include <alphamap_pars_fragment>\n\n#if THREE_VRM_THREE_REVISION >= 132\n  #include <alphatest_pars_fragment>\n#endif\n\n#include <aomap_pars_fragment>\n// #include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n\n#ifdef USE_EMISSIVEMAP\n  uniform mat3 emissiveMapUvTransform;\n#endif\n\n// #include <envmap_common_pars_fragment>\n// #include <envmap_pars_fragment>\n// #include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n\n// #include <bsdfs>\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n  return RECIPROCAL_PI * diffuseColor;\n}\n\n#include <lights_pars_begin>\n\n#if THREE_VRM_THREE_REVISION >= 132\n  #include <normal_pars_fragment>\n#endif\n\n// #include <lights_phong_pars_fragment>\nvarying vec3 vViewPosition;\n\n#if THREE_VRM_THREE_REVISION < 132\n  #ifndef FLAT_SHADED\n    varying vec3 vNormal;\n  #endif\n#endif\n\nstruct MToonMaterial {\n  vec3 diffuseColor;\n  vec3 shadeColor;\n  float shadingShift;\n};\n\nfloat linearstep( float a, float b, float t ) {\n  return clamp( ( t - a ) / ( b - a ), 0.0, 1.0 );\n}\n\n/**\n * Convert NdotL into toon shading factor using shadingShift and shadingToony\n */\nfloat getShading(\n  const in float dotNL,\n  const in float shadow,\n  const in float shadingShift\n) {\n  float shading = dotNL;\n  shading = shading + shadingShift;\n  shading = linearstep( -1.0 + shadingToonyFactor, 1.0 - shadingToonyFactor, shading );\n  shading *= shadow;\n  return shading;\n}\n\n/**\n * Mix diffuseColor and shadeColor using shading factor and light color\n */\nvec3 getDiffuse(\n  const in MToonMaterial material,\n  const in float shading,\n  in vec3 lightColor\n) {\n  #ifdef DEBUG_LITSHADERATE\n    return vec3( BRDF_Lambert( shading * lightColor ) );\n  #endif\n\n  #if THREE_VRM_THREE_REVISION < 132\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n      lightColor *= PI;\n    #endif\n  #endif\n\n  vec3 col = lightColor * BRDF_Lambert( mix( material.shadeColor, material.diffuseColor, shading ) );\n\n  // The "comment out if you want to PBR absolutely" line\n  #ifdef V0_COMPAT_SHADE\n    col = min( col, material.diffuseColor );\n  #endif\n\n  return col;\n}\n\nvoid RE_Direct_MToon( const in IncidentLight directLight, const in GeometricContext geometry, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {\n  float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n  vec3 irradiance = directLight.color;\n\n  #if THREE_VRM_THREE_REVISION < 132\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n      irradiance *= PI;\n    #endif\n  #endif\n\n  // directSpecular will be used for rim lighting, not an actual specular\n  reflectedLight.directSpecular += irradiance;\n\n  irradiance *= dotNL;\n\n  float shading = getShading( dotNL, shadow, material.shadingShift );\n\n  // toon shaded diffuse\n  reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );\n}\n\nvoid RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in GeometricContext geometry, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {\n  // indirect diffuse will use diffuseColor, no shadeColor involved\n  reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n  // directSpecular will be used for rim lighting, not an actual specular\n  reflectedLight.directSpecular += irradiance;\n}\n\n#define RE_Direct RE_Direct_MToon\n#define RE_IndirectDiffuse RE_IndirectDiffuse_MToon\n#define Material_LightProbeLOD( material ) (0)\n\n#include <shadowmap_pars_fragment>\n// #include <bumpmap_pars_fragment>\n\n// #include <normalmap_pars_fragment>\n#ifdef USE_NORMALMAP\n\n  uniform sampler2D normalMap;\n  uniform mat3 normalMapUvTransform;\n  uniform vec2 normalScale;\n\n#endif\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n  uniform mat3 normalMatrix;\n\n#endif\n\n#if ! defined ( USE_TANGENT ) && defined ( TANGENTSPACE_NORMALMAP )\n\n  // Per-Pixel Tangent Space Normal Mapping\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n  // three-vrm specific change: it requires `uv` as an input in order to support uv scrolls\n\n  // Temporary compat against shader change @ Three.js r126\n  // See: #21205, #21307, #21299\n  #if THREE_VRM_THREE_REVISION >= 126\n\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      vec3 N = normalize( surf_norm );\n\n      vec3 q1perp = cross( q1, N );\n      vec3 q0perp = cross( N, q0 );\n\n      vec3 T = q1perp * st0.x + q0perp * st1.x;\n      vec3 B = q1perp * st0.y + q0perp * st1.y;\n\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\n      // TODO: Is this still required? Or shall I make a PR about it?\n      if ( length( T ) == 0.0 || length( B ) == 0.0 ) {\n        return surf_norm;\n      }\n\n      float det = max( dot( T, T ), dot( B, B ) );\n      float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\n      return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\n    }\n\n  #else\n\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\n      // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n      vec3 S = ( q0 * st1.t - q1 * st0.t ) * scale;\n      vec3 T = ( - q0 * st1.s + q1 * st0.s ) * scale;\n\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\n      // TODO: Is this still required? Or shall I make a PR about it?\n\n      if ( length( S ) == 0.0 || length( T ) == 0.0 ) {\n        return surf_norm;\n      }\n\n      S = normalize( S );\n      T = normalize( T );\n      vec3 N = normalize( surf_norm );\n\n      #ifdef DOUBLE_SIDED\n\n        // Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\n\n        bool frontFacing = dot( cross( S, T ), N ) > 0.0;\n\n        mapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\n\n      #else\n\n        mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n      #endif\n\n      mat3 tsn = mat3( S, T, N );\n      return normalize( tsn * mapN );\n\n    }\n\n  #endif\n\n#endif\n\n// #include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n// == post correction ==========================================================\nvoid postCorrection() {\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n}\n\n// == main procedure ===========================================================\nvoid main() {\n  #include <clipping_planes_fragment>\n\n  vec2 uv = vec2(0.5, 0.5);\n\n  #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n    uv = vUv;\n\n    float uvAnimMask = 1.0;\n    #ifdef USE_UVANIMATIONMASKTEXTURE\n      vec2 uvAnimationMaskTextureUv = ( uvAnimationMaskTextureUvTransform * vec3( uv, 1 ) ).xy;\n      uvAnimMask = texture2D( uvAnimationMaskTexture, uvAnimationMaskTextureUv ).b;\n    #endif\n\n    uv = uv + vec2( uvAnimationScrollXOffset, uvAnimationScrollYOffset ) * uvAnimMask;\n    float uvRotCos = cos( uvAnimationRotationPhase * uvAnimMask );\n    float uvRotSin = sin( uvAnimationRotationPhase * uvAnimMask );\n    uv = mat2( uvRotCos, uvRotSin, -uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;\n  #endif\n\n  #ifdef DEBUG_UV\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n      gl_FragColor = vec4( uv, 0.0, 1.0 );\n    #endif\n    return;\n  #endif\n\n  vec4 diffuseColor = vec4( litFactor, opacity );\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  vec3 totalEmissiveRadiance = emissive;\n\n  #include <logdepthbuf_fragment>\n\n  // #include <map_fragment>\n  #ifdef USE_MAP\n    vec2 mapUv = ( mapUvTransform * vec3( uv, 1 ) ).xy;\n    vec4 texelColor = texture2D( map, mapUv );\n    texelColor = mapTexelToLinear( texelColor );\n    diffuseColor *= texelColor;\n  #endif\n\n  // #include <color_fragment>\n  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )\n    diffuseColor.rgb *= vColor;\n  #endif\n\n  // #include <alphamap_fragment>\n\n  #include <alphatest_fragment>\n\n  // #include <specularmap_fragment>\n  #include <normal_fragment_begin>\n\n  #ifdef OUTLINE\n    normal *= -1.0;\n  #endif\n\n  // #include <normal_fragment_maps>\n\n  #ifdef OBJECTSPACE_NORMALMAP\n\n    vec2 normalMapUv = ( normalMapUvTransform * vec3( uv, 1 ) ).xy;\n    normal = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n    #ifdef FLIP_SIDED\n\n      normal = - normal;\n\n    #endif\n\n    #ifdef DOUBLE_SIDED\n\n      // Temporary compat against shader change @ Three.js r126\n      // See: #21205, #21307, #21299\n      #if THREE_VRM_THREE_REVISION >= 126\n\n        normal = normal * faceDirection;\n\n      #else\n\n        normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n      #endif\n\n    #endif\n\n    normal = normalize( normalMatrix * normal );\n\n  #elif defined( TANGENTSPACE_NORMALMAP )\n\n    vec2 normalMapUv = ( normalMapUvTransform * vec3( uv, 1 ) ).xy;\n    vec3 mapN = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0;\n    mapN.xy *= normalScale;\n\n    #ifdef USE_TANGENT\n\n      normal = normalize( vTBN * mapN );\n\n    #else\n\n      // Temporary compat against shader change @ Three.js r126\n      // See: #21205, #21307, #21299\n      #if THREE_VRM_THREE_REVISION >= 126\n\n        normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN, faceDirection );\n\n      #else\n\n        normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN );\n\n      #endif\n\n    #endif\n\n  #endif\n\n  // #include <emissivemap_fragment>\n  #ifdef USE_EMISSIVEMAP\n    vec2 emissiveMapUv = ( emissiveMapUvTransform * vec3( uv, 1 ) ).xy;\n    totalEmissiveRadiance *= emissiveMapTexelToLinear( texture2D( emissiveMap, emissiveMapUv ) ).rgb;\n  #endif\n\n  #ifdef DEBUG_NORMAL\n    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );\n    return;\n  #endif\n\n  // -- MToon: lighting --------------------------------------------------------\n  // accumulation\n  // #include <lights_phong_fragment>\n  MToonMaterial material;\n\n  material.diffuseColor = diffuseColor.rgb;\n\n  material.shadeColor = shadeColorFactor;\n  #ifdef USE_SHADEMULTIPLYTEXTURE\n    material.shadeColor *= shadeMultiplyTextureTexelToLinear( texture2D( shadeMultiplyTexture, uv ) ).rgb;\n  #endif\n\n  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )\n    material.shadeColor.rgb *= vColor;\n  #endif\n\n  material.shadingShift = shadingShiftFactor;\n  #ifdef USE_SHADINGSHIFTTEXTURE\n    vec2 shadingShiftTextureUv = ( shadingShiftTextureUvTransform * vec3( uv, 1 ) ).xy;\n    material.shadingShift += texture2D( shadingShiftTexture, shadingShiftTextureUv ).r * shadingShiftTextureScale;\n  #endif\n\n  // #include <lights_fragment_begin>\n\n  // MToon Specific changes:\n  // Since we want to take shadows into account of shading instead of irradiance,\n  // we had to modify the codes that multiplies the results of shadowmap into color of direct lights.\n\n  GeometricContext geometry;\n\n  geometry.position = - vViewPosition;\n  geometry.normal = normal;\n  geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n  #ifdef CLEARCOAT\n\n    geometry.clearcoatNormal = clearcoatNormal;\n\n  #endif\n\n  IncidentLight directLight;\n\n  // since these variables will be used in unrolled loop, we have to define in prior\n  float shadow;\n\n  #if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n    PointLight pointLight;\n    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n    PointLightShadow pointLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n      pointLight = pointLights[ i ];\n\n      #if THREE_VRM_THREE_REVISION >= 132\n        getPointLightInfo( pointLight, geometry, directLight );\n      #else\n        getPointDirectLightIrradiance( pointLight, geometry, directLight );\n      #endif\n\n      shadow = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n      pointLightShadow = pointLightShadows[ i ];\n      shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n      #endif\n\n      RE_Direct( directLight, geometry, material, shadow, reflectedLight );\n\n    }\n    #pragma unroll_loop_end\n\n  #endif\n\n  #if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n    SpotLight spotLight;\n    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n    SpotLightShadow spotLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n      spotLight = spotLights[ i ];\n\n      #if THREE_VRM_THREE_REVISION >= 132\n        getSpotLightInfo( spotLight, geometry, directLight );\n      #else\n        getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n      #endif\n\n      shadow = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n      spotLightShadow = spotLightShadows[ i ];\n      shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n      #endif\n\n      RE_Direct( directLight, geometry, material, shadow, reflectedLight );\n\n    }\n    #pragma unroll_loop_end\n\n  #endif\n\n  #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n    DirectionalLight directionalLight;\n    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n    DirectionalLightShadow directionalLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n      directionalLight = directionalLights[ i ];\n\n      #if THREE_VRM_THREE_REVISION >= 132\n        getDirectionalLightInfo( directionalLight, geometry, directLight );\n      #else\n        getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n      #endif\n\n      shadow = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n      directionalLightShadow = directionalLightShadows[ i ];\n      shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n      #endif\n\n      RE_Direct( directLight, geometry, material, shadow, reflectedLight );\n\n    }\n    #pragma unroll_loop_end\n\n  #endif\n\n  // #if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n  //   RectAreaLight rectAreaLight;\n\n  //   #pragma unroll_loop_start\n  //   for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n  //     rectAreaLight = rectAreaLights[ i ];\n  //     RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n  //   }\n  //   #pragma unroll_loop_end\n\n  // #endif\n\n  #if defined( RE_IndirectDiffuse )\n\n    vec3 iblIrradiance = vec3( 0.0 );\n\n    vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n    #if THREE_VRM_THREE_REVISION >= 133\n      irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n    #else\n      irradiance += getLightProbeIrradiance( lightProbe, geometry );\n    #endif\n\n    #if ( NUM_HEMI_LIGHTS > 0 )\n\n      #pragma unroll_loop_start\n      for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n        irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n      }\n      #pragma unroll_loop_end\n\n    #endif\n\n  #endif\n\n  // #if defined( RE_IndirectSpecular )\n\n  //   vec3 radiance = vec3( 0.0 );\n  //   vec3 clearcoatRadiance = vec3( 0.0 );\n\n  // #endif\n\n  #include <lights_fragment_maps>\n  #include <lights_fragment_end>\n\n  // modulation\n  #include <aomap_fragment>\n\n  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\n  #if defined( OUTLINE )\n    gl_FragColor = vec4(\n      outlineColorFactor.rgb * mix( vec3( 1.0 ), col, outlineLightingMixFactor ),\n      diffuseColor.a\n    );\n    postCorrection();\n    return;\n  #endif\n\n  #ifdef DEBUG_LITSHADERATE\n    gl_FragColor = vec4( col, diffuseColor.a );\n    postCorrection();\n    return;\n  #endif\n\n  // -- MToon: rim lighting -----------------------------------------\n  vec3 viewDir = normalize( vViewPosition );\n\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n    reflectedLight.directSpecular /= PI;\n  #endif\n  vec3 rimMix = mix( vec3( 1.0 ), reflectedLight.directSpecular, 1.0 );\n\n  vec3 rim = parametricRimColorFactor * pow( saturate( 1.0 - dot( viewDir, normal ) + parametricRimLiftFactor ), parametricRimFresnelPowerFactor );\n\n  #ifdef USE_MATCAPTEXTURE\n    {\n      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );\n      vec3 y = cross( viewDir, x ); // guaranteed to be normalized\n      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );\n      sphereUv = ( matcapTextureUvTransform * vec3( sphereUv, 1 ) ).xy;\n      vec3 matcap = matcapTextureTexelToLinear( texture2D( matcapTexture, sphereUv ) ).rgb;\n      rim += matcapFactor * matcap;\n    }\n  #endif\n\n  #ifdef USE_RIMMULTIPLYTEXTURE\n    vec2 rimMultiplyTextureUv = ( rimMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;\n    rim *= rimMultiplyTextureTexelToLinear( texture2D( rimMultiplyTexture, rimMultiplyTextureUv ) ).rgb;\n  #endif\n\n  col += rimMix * rim;\n\n  // -- MToon: Emission --------------------------------------------------------\n  col += totalEmissiveRadiance;\n\n  // #include <envmap_fragment>\n\n  // -- Almost done! -----------------------------------------------------------\n  gl_FragColor = vec4( col, diffuseColor.a );\n  postCorrection();\n}'}),this.uvAnimationScrollXSpeedFactor=0,this.uvAnimationScrollYSpeedFactor=0,this.uvAnimationRotationSpeedFactor=0,this.normalMapType=n.TangentSpaceNormalMap,this._ignoreVertexColor=!0,this._v0CompatShade=!1,this._debugMode=ie.None,this._outlineWidthMode=ne.None,this._isOutline=!1,e.transparentWithZWrite&&(e.depthWrite=!0),delete e.transparentWithZWrite,e.fog=!0,e.lights=!0,e.clipping=!0,parseInt(n.REVISION,10)<129&&(e.skinning=e.skinning||!1),parseInt(n.REVISION,10)<131&&(e.morphTargets=e.morphTargets||!1,e.morphNormals=e.morphNormals||!1),this.uniforms=n.UniformsUtils.merge([n.UniformsLib.common,n.UniformsLib.normalmap,n.UniformsLib.emissivemap,n.UniformsLib.fog,n.UniformsLib.lights,{litFactor:{value:new n.Color(1,1,1)},mapUvTransform:{value:new n.Matrix3},colorAlpha:{value:1},normalMapUvTransform:{value:new n.Matrix3},shadeColorFactor:{value:new n.Color(.97,.81,.86)},shadeMultiplyTexture:{value:null},shadeMultiplyTextureUvTransform:{value:new n.Matrix3},shadingShiftFactor:{value:0},shadingShiftTexture:{value:null},shadingShiftTextureUvTransform:{value:new n.Matrix3},shadingShiftTextureScale:{value:null},shadingToonyFactor:{value:.9},giEqualizationFactor:{value:.9},matcapFactor:{value:new n.Color(1,1,1)},matcapTexture:{value:null},matcapTextureUvTransform:{value:new n.Matrix3},parametricRimColorFactor:{value:new n.Color(0,0,0)},rimMultiplyTexture:{value:null},rimMultiplyTextureUvTransform:{value:new n.Matrix3},rimLightingMixFactor:{value:0},parametricRimFresnelPowerFactor:{value:1},parametricRimLiftFactor:{value:0},emissive:{value:new n.Color(0,0,0)},emissiveMapUvTransform:{value:new n.Matrix3},outlineWidthMultiplyTexture:{value:null},outlineWidthMultiplyTextureUvTransform:{value:new n.Matrix3},outlineWidthFactor:{value:.5},outlineColorFactor:{value:new n.Color(0,0,0)},outlineLightingMixFactor:{value:1},uvAnimationMaskTexture:{value:null},uvAnimationMaskTextureUvTransform:{value:new n.Matrix3},uvAnimationScrollXOffset:{value:0},uvAnimationScrollYOffset:{value:0},uvAnimationRotationPhase:{value:0}},e.uniforms]),this.setValues(e),this._uploadUniformsWorkaround(),this.customProgramCacheKey=()=>[this._ignoreVertexColor?"ignoreVertexColor":"",this._v0CompatShade?"v0CompatShade":"","none"!==this._debugMode?`debugMode:${this._debugMode}`:"","none"!==this._outlineWidthMode?`outlineWidthMode:${this._outlineWidthMode}`:"",this._isOutline?"isOutline":"",...Object.entries(this._generateDefines()).map((([e,t])=>`${e}:${t}`)),this.matcapTexture?`matcapTextureEncoding:${this.matcapTexture.encoding}`:"",this.shadeMultiplyTexture?`shadeMultiplyTextureEncoding:${this.shadeMultiplyTexture.encoding}`:"",this.rimMultiplyTexture?`rimMultiplyTextureEncoding:${this.rimMultiplyTexture.encoding}`:""].join(","),this.onBeforeCompile=(e,t)=>{const i=t.capabilities.isWebGL2,r=parseInt(n.REVISION,10),o=Object.entries(Object.assign(Object.assign({},this._generateDefines()),this.defines)).filter((([e,t])=>!!t)).map((([e,t])=>`#define ${e} ${t}`)).join("\n")+"\n",s=(null!==this.matcapTexture?te("matcapTextureTexelToLinear",re(this.matcapTexture,i))+"\n":"")+(null!==this.shadeMultiplyTexture?te("shadeMultiplyTextureTexelToLinear",re(this.shadeMultiplyTexture,i))+"\n":"")+(null!==this.rimMultiplyTexture?te("rimMultiplyTextureTexelToLinear",re(this.rimMultiplyTexture,i))+"\n":"");e.vertexShader=o+e.vertexShader,e.fragmentShader=o+s+e.fragmentShader,r<132&&(e.fragmentShader=e.fragmentShader.replace("#include <normal_pars_fragment>",""),e.fragmentShader=e.fragmentShader.replace("#include <alphatest_pars_fragment>",""))}}get color(){return this.uniforms.litFactor.value}set color(e){this.uniforms.litFactor.value=e}get map(){return this.uniforms.map.value}set map(e){this.uniforms.map.value=e}get normalMap(){return this.uniforms.normalMap.value}set normalMap(e){this.uniforms.normalMap.value=e}get normalScale(){return this.uniforms.normalScale.value}set normalScale(e){this.uniforms.normalScale.value=e}get emissive(){return this.uniforms.emissive.value}set emissive(e){this.uniforms.emissive.value=e}get emissiveMap(){return this.uniforms.emissiveMap.value}set emissiveMap(e){this.uniforms.emissiveMap.value=e}get shadeColorFactor(){return this.uniforms.shadeColorFactor.value}set shadeColorFactor(e){this.uniforms.shadeColorFactor.value=e}get shadeMultiplyTexture(){return this.uniforms.shadeMultiplyTexture.value}set shadeMultiplyTexture(e){this.uniforms.shadeMultiplyTexture.value=e}get shadingShiftFactor(){return this.uniforms.shadingShiftFactor.value}set shadingShiftFactor(e){this.uniforms.shadingShiftFactor.value=e}get shadingShiftTexture(){return this.uniforms.shadingShiftTexture.value}set shadingShiftTexture(e){this.uniforms.shadingShiftTexture.value=e}get shadingShiftTextureScale(){return this.uniforms.shadingShiftTextureScale.value}set shadingShiftTextureScale(e){this.uniforms.shadingShiftTextureScale.value=e}get shadingToonyFactor(){return this.uniforms.shadingToonyFactor.value}set shadingToonyFactor(e){this.uniforms.shadingToonyFactor.value=e}get giEqualizationFactor(){return this.uniforms.giEqualizationFactor.value}set giEqualizationFactor(e){this.uniforms.giEqualizationFactor.value=e}get matcapFactor(){return this.uniforms.matcapFactor.value}set matcapFactor(e){this.uniforms.matcapFactor.value=e}get matcapTexture(){return this.uniforms.matcapTexture.value}set matcapTexture(e){this.uniforms.matcapTexture.value=e}get parametricRimColorFactor(){return this.uniforms.parametricRimColorFactor.value}set parametricRimColorFactor(e){this.uniforms.parametricRimColorFactor.value=e}get rimMultiplyTexture(){return this.uniforms.rimMultiplyTexture.value}set rimMultiplyTexture(e){this.uniforms.rimMultiplyTexture.value=e}get rimLightingMixFactor(){return this.uniforms.rimLightingMixFactor.value}set rimLightingMixFactor(e){this.uniforms.rimLightingMixFactor.value=e}get parametricRimFresnelPowerFactor(){return this.uniforms.parametricRimFresnelPowerFactor.value}set parametricRimFresnelPowerFactor(e){this.uniforms.parametricRimFresnelPowerFactor.value=e}get parametricRimLiftFactor(){return this.uniforms.parametricRimLiftFactor.value}set parametricRimLiftFactor(e){this.uniforms.parametricRimLiftFactor.value=e}get outlineWidthMultiplyTexture(){return this.uniforms.outlineWidthMultiplyTexture.value}set outlineWidthMultiplyTexture(e){this.uniforms.outlineWidthMultiplyTexture.value=e}get outlineWidthFactor(){return this.uniforms.outlineWidthFactor.value}set outlineWidthFactor(e){this.uniforms.outlineWidthFactor.value=e}get outlineColorFactor(){return this.uniforms.outlineColorFactor.value}set outlineColorFactor(e){this.uniforms.outlineColorFactor.value=e}get outlineLightingMixFactor(){return this.uniforms.outlineLightingMixFactor.value}set outlineLightingMixFactor(e){this.uniforms.outlineLightingMixFactor.value=e}get uvAnimationMaskTexture(){return this.uniforms.uvAnimationMaskTexture.value}set uvAnimationMaskTexture(e){this.uniforms.uvAnimationMaskTexture.value=e}get uvAnimationScrollXOffset(){return this.uniforms.uvAnimationScrollXOffset.value}set uvAnimationScrollXOffset(e){this.uniforms.uvAnimationScrollXOffset.value=e}get uvAnimationScrollYOffset(){return this.uniforms.uvAnimationScrollYOffset.value}set uvAnimationScrollYOffset(e){this.uniforms.uvAnimationScrollYOffset.value=e}get uvAnimationRotationPhase(){return this.uniforms.uvAnimationRotationPhase.value}set uvAnimationRotationPhase(e){this.uniforms.uvAnimationRotationPhase.value=e}get ignoreVertexColor(){return this._ignoreVertexColor}set ignoreVertexColor(e){this._ignoreVertexColor=e,this.needsUpdate=!0}get v0CompatShade(){return this._v0CompatShade}set v0CompatShade(e){this._v0CompatShade=e,this.needsUpdate=!0}get debugMode(){return this._debugMode}set debugMode(e){this._debugMode=e,this.needsUpdate=!0}get outlineWidthMode(){return this._outlineWidthMode}set outlineWidthMode(e){this._outlineWidthMode=e,this.needsUpdate=!0}get isOutline(){return this._isOutline}set isOutline(e){this._isOutline=e,this.needsUpdate=!0}get isMToonMaterial(){return!0}update(e){this._uploadUniformsWorkaround(),this._updateUVAnimation(e)}copy(e){return super.copy(e),this.map=e.map,this.normalMap=e.normalMap,this.emissiveMap=e.emissiveMap,this.shadeMultiplyTexture=e.shadeMultiplyTexture,this.shadingShiftTexture=e.shadingShiftTexture,this.matcapTexture=e.matcapTexture,this.rimMultiplyTexture=e.rimMultiplyTexture,this.outlineWidthMultiplyTexture=e.outlineWidthMultiplyTexture,this.uvAnimationMaskTexture=e.uvAnimationMaskTexture,this.normalMapType=e.normalMapType,this.uvAnimationScrollXSpeedFactor=e.uvAnimationScrollXSpeedFactor,this.uvAnimationScrollYSpeedFactor=e.uvAnimationScrollYSpeedFactor,this.uvAnimationRotationSpeedFactor=e.uvAnimationRotationSpeedFactor,this.ignoreVertexColor=e.ignoreVertexColor,this.v0CompatShade=e.v0CompatShade,this.debugMode=e.debugMode,this.outlineWidthMode=e.outlineWidthMode,this.isOutline=e.isOutline,this.needsUpdate=!0,this}_updateUVAnimation(e){this.uniforms.uvAnimationScrollXOffset.value+=e*this.uvAnimationScrollXSpeedFactor,this.uniforms.uvAnimationScrollYOffset.value+=e*this.uvAnimationScrollYSpeedFactor,this.uniforms.uvAnimationRotationPhase.value+=e*this.uvAnimationRotationSpeedFactor,this.uniformsNeedUpdate=!0}_uploadUniformsWorkaround(){this.uniforms.opacity.value=this.opacity,this._updateTextureMatrix(this.uniforms.map,this.uniforms.mapUvTransform),this._updateTextureMatrix(this.uniforms.normalMap,this.uniforms.normalMapUvTransform),this._updateTextureMatrix(this.uniforms.emissiveMap,this.uniforms.emissiveMapUvTransform),this._updateTextureMatrix(this.uniforms.shadeMultiplyTexture,this.uniforms.shadeMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.shadingShiftTexture,this.uniforms.shadingShiftTextureUvTransform),this._updateTextureMatrix(this.uniforms.matcapTexture,this.uniforms.matcapTextureUvTransform),this._updateTextureMatrix(this.uniforms.rimMultiplyTexture,this.uniforms.rimMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.outlineWidthMultiplyTexture,this.uniforms.outlineWidthMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.uvAnimationMaskTexture,this.uniforms.uvAnimationMaskTextureUvTransform);parseInt(n.REVISION,10)>=132&&(this.uniforms.alphaTest.value=this.alphaTest),this.uniformsNeedUpdate=!0}_generateDefines(){const e=parseInt(n.REVISION,10),t=null!==this.outlineWidthMultiplyTexture,i=null!==this.map||null!==this.emissiveMap||null!==this.shadeMultiplyTexture||null!==this.shadingShiftTexture||null!==this.rimMultiplyTexture||null!==this.uvAnimationMaskTexture;return{THREE_VRM_THREE_REVISION:e,OUTLINE:this._isOutline,MTOON_USE_UV:t||i,MTOON_UVS_VERTEX_ONLY:t&&!i,V0_COMPAT_SHADE:this._v0CompatShade,USE_SHADEMULTIPLYTEXTURE:null!==this.shadeMultiplyTexture,USE_SHADINGSHIFTTEXTURE:null!==this.shadingShiftTexture,USE_MATCAPTEXTURE:null!==this.matcapTexture,USE_RIMMULTIPLYTEXTURE:null!==this.rimMultiplyTexture,USE_OUTLINEWIDTHMULTIPLYTEXTURE:null!==this.outlineWidthMultiplyTexture,USE_UVANIMATIONMASKTEXTURE:null!==this.uvAnimationMaskTexture,IGNORE_VERTEX_COLOR:!0===this._ignoreVertexColor,DEBUG_NORMAL:"normal"===this._debugMode,DEBUG_LITSHADERATE:"litShadeRate"===this._debugMode,DEBUG_UV:"uv"===this._debugMode,OUTLINE_WIDTH_WORLD:this._outlineWidthMode===ne.WorldCoordinates,OUTLINE_WIDTH_SCREEN:this._outlineWidthMode===ne.ScreenCoordinates}}_updateTextureMatrix(e,t){e.value&&(e.value.matrixAutoUpdate&&e.value.updateMatrix(),t.value.copy(e.value.matrix))}}class se{constructor(e,t){this._parser=e,this._materialParams=t,this._pendings=[]}get pending(){return Promise.all(this._pendings)}assignPrimitive(e,t){null!=t&&(this._materialParams[e]=t)}assignColor(e,t,i){null!=t&&(this._materialParams[e]=(new n.Color).fromArray(t),i&&this._materialParams[e].convertSRGBToLinear())}assignTexture(e,t,i){return ee(this,void 0,void 0,(function*(){const r=(()=>ee(this,void 0,void 0,(function*(){null!=t&&(yield this._parser.assignTexture(this._materialParams,e,t),i&&(this._materialParams[e].encoding=n.sRGBEncoding))})))();return this._pendings.push(r),r}))}assignTextureByIndex(e,t,i){return ee(this,void 0,void 0,(function*(){return this.assignTexture(e,null!=t?{index:t}:void 0,i)}))}}class ae{constructor(e,t={}){var i,n,r;this.parser=e,this.renderOrderOffset=null!==(i=t.renderOrderOffset)&&void 0!==i?i:0,this.v0CompatShade=null!==(n=t.v0CompatShade)&&void 0!==n&&n,this.debugMode=null!==(r=t.debugMode)&&void 0!==r?r:"none",this._mToonMaterialSet=new Set}get name(){return ae.EXTENSION_NAME}beforeRoot(){return ee(this,void 0,void 0,(function*(){this._removeUnlitExtensionIfMToonExists()}))}afterRoot(e){return ee(this,void 0,void 0,(function*(){e.userData.vrmMToonMaterials=Array.from(this._mToonMaterialSet)}))}getMaterialType(e){return this._getMToonExtension(e)?oe:null}extendMaterialParams(e,t){const i=this._getMToonExtension(e);return i?this._extendMaterialParams(i,t):null}loadMesh(e){return ee(this,void 0,void 0,(function*(){const t=this.parser,i=t.json.meshes[e].primitives,n=yield t.loadMesh(e);if(1===i.length){const e=n,t=i[0].material;null!=t&&this._setupPrimitive(e,t)}else{const e=n;for(let t=0;t<i.length;t++){const n=e.children[t],r=i[t].material;null!=r&&this._setupPrimitive(n,r)}}return n}))}_removeUnlitExtensionIfMToonExists(){this.parser.json.materials.map(((e,t)=>{var i;this._getMToonExtension(t)&&(null===(i=e.extensions)||void 0===i?void 0:i.KHR_materials_unlit)&&delete e.extensions.KHR_materials_unlit}))}_getMToonExtension(e){var t;const i=null===(t=this.parser.json.materials[e].extensions)||void 0===t?void 0:t[ae.EXTENSION_NAME];if(null==i)return;return"1.0-beta"===i.specVersion?i:void 0}_extendMaterialParams(e,t){var i;return ee(this,void 0,void 0,(function*(){delete t.metalness,delete t.roughness;const n=new se(this.parser,t);n.assignPrimitive("transparentWithZWrite",e.transparentWithZWrite),n.assignColor("shadeColorFactor",e.shadeColorFactor),n.assignTexture("shadeMultiplyTexture",e.shadeMultiplyTexture,!0),n.assignPrimitive("shadingShiftFactor",e.shadingShiftFactor),n.assignTexture("shadingShiftTexture",e.shadingShiftTexture,!0),n.assignPrimitive("shadingShiftTextureScale",null===(i=e.shadingShiftTexture)||void 0===i?void 0:i.scale),n.assignPrimitive("shadingToonyFactor",e.shadingToonyFactor),n.assignPrimitive("giEqualizationFactor",e.giEqualizationFactor),n.assignColor("matcapFactor",e.matcapFactor),n.assignTexture("matcapTexture",e.matcapTexture,!0),n.assignColor("parametricRimColorFactor",e.parametricRimColorFactor),n.assignTexture("rimMultiplyTexture",e.rimMultiplyTexture,!0),n.assignPrimitive("rimLightingMixFactor",e.rimLightingMixFactor),n.assignPrimitive("parametricRimFresnelPowerFactor",e.parametricRimFresnelPowerFactor),n.assignPrimitive("parametricRimLiftFactor",e.parametricRimLiftFactor),n.assignPrimitive("outlineWidthMode",e.outlineWidthMode),n.assignPrimitive("outlineWidthFactor",e.outlineWidthFactor),n.assignTexture("outlineWidthMultiplyTexture",e.outlineWidthMultiplyTexture,!1),n.assignColor("outlineColorFactor",e.outlineColorFactor),n.assignPrimitive("outlineLightingMixFactor",e.outlineLightingMixFactor),n.assignTexture("uvAnimationMaskTexture",e.uvAnimationMaskTexture,!1),n.assignPrimitive("uvAnimationScrollXSpeedFactor",e.uvAnimationScrollXSpeedFactor),n.assignPrimitive("uvAnimationScrollYSpeedFactor",e.uvAnimationScrollYSpeedFactor),n.assignPrimitive("uvAnimationRotationSpeedFactor",e.uvAnimationRotationSpeedFactor),n.assignPrimitive("v0CompatShade",this.v0CompatShade),n.assignPrimitive("debugMode",this.debugMode),yield n.pending}))}_setupPrimitive(e,t){const i=this._getMToonExtension(t);if(i){const t=this._parseRenderOrder(i);return e.renderOrder=t+this.renderOrderOffset,this._generateOutline(e),void this._addToMaterialSet(e)}}_generateOutline(e){const t=e.material;if(!(t instanceof oe))return;if("none"===t.outlineWidthMode||t.outlineWidthFactor<=0)return;e.material=[t];const i=t.clone();i.name+=" (Outline)",i.isOutline=!0,i.side=n.BackSide,e.material.push(i);const r=e.geometry,o=r.index?r.index.count:r.attributes.position.count/3;r.addGroup(0,o,0),r.addGroup(0,o,1)}_addToMaterialSet(e){const t=e.material,i=new Set;Array.isArray(t)?t.forEach((e=>i.add(e))):i.add(t);for(const e of i)e instanceof oe&&this._mToonMaterialSet.add(e)}_parseRenderOrder(e){var t;return(e.transparentWithZWrite?0:19)+(null!==(t=e.renderQueueOffsetNumber)&&void 0!==t?t:0)}}
/*!
     * @pixiv/three-vrm-materials-hdr-emissive-multiplier v1.0.0-beta.7
     * Support VRMC_hdr_emissiveMultiplier for @pixiv/three-vrm
     *
     * Copyright (c) 2020-2021 pixiv Inc.
     * @pixiv/three-vrm-materials-hdr-emissive-multiplier is distributed under MIT License
     * https://github.com/pixiv/three-vrm/blob/release/LICENSE
     */
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
function le(e,t,i,n){return new(i||(i=Promise))((function(r,o){function s(e){try{l(n.next(e))}catch(e){o(e)}}function a(e){try{l(n.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?r(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(s,a)}l((n=n.apply(e,t||[])).next())}))}ae.EXTENSION_NAME="VRMC_materials_mtoon";class ue{constructor(e){this.parser=e}get name(){return ue.EXTENSION_NAME}afterRoot(e){return le(this,void 0,void 0,(function*(){const t=this.parser,i=[];e.scene.traverse((e=>{const t=e.material;t&&i.push(t)})),i.forEach((e=>{var i;const r=function(e,t){var i,r;let o=null;if(parseInt(n.REVISION,10)>=133)o=null!==(r=null===(i=e.associations.get(t))||void 0===i?void 0:i.materials)&&void 0!==r?r:null;else{const i=e.associations.get(t);"materials"===(null==i?void 0:i.type)&&(o=i.index)}return o}(t,e);if(null!=r){const t=this._getHDREmissiveMultiplierExtension(r);t&&(null===(i=e.emissive)||void 0===i||i.multiplyScalar(t.emissiveMultiplier))}}))}))}_getHDREmissiveMultiplierExtension(e){var t;const i=null===(t=this.parser.json.materials[e].extensions)||void 0===t?void 0:t[ue.EXTENSION_NAME];if(null!=i)return i}}
/*!
     * @pixiv/three-vrm-materials-v0compat v1.0.0-beta.7
     * VRM0.0 materials compatibility layer plugin for @pixiv/three-vrm
     *
     * Copyright (c) 2020-2021 pixiv Inc.
     * @pixiv/three-vrm-materials-v0compat is distributed under MIT License
     * https://github.com/pixiv/three-vrm/blob/release/LICENSE
     */
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
function de(e,t,i,n){return new(i||(i=Promise))((function(r,o){function s(e){try{l(n.next(e))}catch(e){o(e)}}function a(e){try{l(n.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?r(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(s,a)}l((n=n.apply(e,t||[])).next())}))}function he(e){return Math.pow(e,2.2)}ue.EXTENSION_NAME="VRMC_materials_hdr_emissiveMultiplier";class ce{constructor(e){var t;this.parser=e;const i=this.parser.json;i.extensionsUsed=null!==(t=i.extensionsUsed)&&void 0!==t?t:[],-1===i.extensionsUsed.indexOf("KHR_texture_transform")&&i.extensionsUsed.push("KHR_texture_transform")}get name(){return"VRMMaterialsV0CompatPlugin"}beforeRoot(){var e;return de(this,void 0,void 0,(function*(){const t=this.parser.json,i=null===(e=t.extensions)||void 0===e?void 0:e.VRM,n=null==i?void 0:i.materialProperties;n&&n.forEach(((e,i)=>{var n;if("VRM/MToon"===e.shader){const n=this._parseV0MToonProperties(e,t.materials[i]);t.materials[i]=n}else if(null===(n=e.shader)||void 0===n?void 0:n.startsWith("VRM/Unlit")){const n=this._parseV0UnlitProperties(e,t.materials[i]);t.materials[i]=n}else"VRM_USE_GLTFSHADER"===e.shader||console.warn(`VRMMaterialsV0CompatPlugin: Unknown shader: ${e.shader}`)}))}))}_parseV0MToonProperties(e,t){var i,r,o,s,a,l,u,d,h,c,p,m,f,v,g,_,x,M,y,T,S,R,w,P,E,L,A,b,I,O,U,V,C,N,F,D,B,k,W,H,j,z,X,Y;const G=null!==(r=null===(i=e.keywordMap)||void 0===i?void 0:i._ALPHABLEND_ON)&&void 0!==r&&r,q=1===(null===(o=e.floatProperties)||void 0===o?void 0:o._ZWrite)&&G,Q=this._v0ParseRenderQueue(e),$=null!==(a=null===(s=e.keywordMap)||void 0===s?void 0:s._ALPHATEST_ON)&&void 0!==a&&a,Z=G?"BLEND":$?"MASK":"OPAQUE",K=$?null===(l=e.floatProperties)||void 0===l?void 0:l._Cutoff:void 0,J=0===(null!==(d=null===(u=e.floatProperties)||void 0===u?void 0:u._CullMode)&&void 0!==d?d:2),ee=this._portTextureTransform(e),te=null===(c=null===(h=e.vectorProperties)||void 0===h?void 0:h._Color)||void 0===c?void 0:c.map(((e,t)=>3===t?e:he(e))),ie=null===(p=e.textureProperties)||void 0===p?void 0:p._MainTex,ne=null!=ie?{index:ie,extensions:Object.assign({},ee)}:void 0,re=null===(m=e.floatProperties)||void 0===m?void 0:m._BumpScale,oe=null===(f=e.textureProperties)||void 0===f?void 0:f._BumpMap,se=null!=oe?{index:oe,scale:re,extensions:Object.assign({},ee)}:void 0,ae=null===(g=null===(v=e.vectorProperties)||void 0===v?void 0:v._EmissionColor)||void 0===g?void 0:g.map(he),le=null===(_=e.textureProperties)||void 0===_?void 0:_._EmissionMap,ue=null!=le?{index:le,extensions:Object.assign({},ee)}:void 0,de=null===(M=null===(x=e.vectorProperties)||void 0===x?void 0:x._ShadeColor)||void 0===M?void 0:M.map(he),ce=null===(y=e.textureProperties)||void 0===y?void 0:y._ShadeTexture,pe=null!=ce?{index:ce,extensions:Object.assign({},ee)}:void 0;let me=null!==(S=null===(T=e.floatProperties)||void 0===T?void 0:T._ShadeShift)&&void 0!==S?S:0,fe=null!==(w=null===(R=e.floatProperties)||void 0===R?void 0:R._ShadeToony)&&void 0!==w?w:.9;fe=n.MathUtils.lerp(fe,1,.5+.5*me),me=-me-(1-fe);const ve=null===(P=e.floatProperties)||void 0===P?void 0:P._IndirectLightIntensity,ge=ve?1-ve:void 0,_e=null===(E=e.textureProperties)||void 0===E?void 0:E._SphereAdd,xe=null!=_e?{index:_e}:void 0,Me=null===(L=e.floatProperties)||void 0===L?void 0:L._RimLightingMix,ye=null===(A=e.textureProperties)||void 0===A?void 0:A._RimTexture,Te=null!=ye?{index:ye,extensions:Object.assign({},ee)}:void 0,Se=null===(I=null===(b=e.vectorProperties)||void 0===b?void 0:b._RimColor)||void 0===I?void 0:I.map(he),Re=null===(O=e.floatProperties)||void 0===O?void 0:O._RimFresnelPower,we=null===(U=e.floatProperties)||void 0===U?void 0:U._RimLift,Pe=["none","worldCoordinates","screenCoordinates"][null!==(C=null===(V=e.floatProperties)||void 0===V?void 0:V._OutlineWidthMode)&&void 0!==C?C:0];let Ee=null!==(F=null===(N=e.floatProperties)||void 0===N?void 0:N._OutlineWidth)&&void 0!==F?F:0;Ee*=.01;const Le=null===(D=e.textureProperties)||void 0===D?void 0:D._OutlineWidthTexture,Ae=null!=Le?{index:Le,extensions:Object.assign({},ee)}:void 0,be=null===(k=null===(B=e.vectorProperties)||void 0===B?void 0:B._OutlineColor)||void 0===k?void 0:k.map(he),Ie=1===(null===(W=e.floatProperties)||void 0===W?void 0:W._OutlineColorMode)?null===(H=e.floatProperties)||void 0===H?void 0:H._OutlineLightingMix:0,Oe=null===(j=e.textureProperties)||void 0===j?void 0:j._UvAnimMaskTexture,Ue=null!=Oe?{index:Oe,extensions:Object.assign({},ee)}:void 0,Ve=null===(z=e.floatProperties)||void 0===z?void 0:z._UvAnimScrollX;let Ce=null===(X=e.floatProperties)||void 0===X?void 0:X._UvAnimScrollY;null!=Ce&&(Ce=-Ce);const Ne={specVersion:"1.0-beta",transparentWithZWrite:q,renderQueueOffsetNumber:Q,shadeColorFactor:de,shadeMultiplyTexture:pe,shadingShiftFactor:me,shadingToonyFactor:fe,giEqualizationFactor:ge,matcapTexture:xe,rimLightingMixFactor:Me,rimMultiplyTexture:Te,parametricRimColorFactor:Se,parametricRimFresnelPowerFactor:Re,parametricRimLiftFactor:we,outlineWidthMode:Pe,outlineWidthFactor:Ee,outlineWidthMultiplyTexture:Ae,outlineColorFactor:be,outlineLightingMixFactor:Ie,uvAnimationMaskTexture:Ue,uvAnimationScrollXSpeedFactor:Ve,uvAnimationScrollYSpeedFactor:Ce,uvAnimationRotationSpeedFactor:null===(Y=e.floatProperties)||void 0===Y?void 0:Y._UvAnimRotation};return Object.assign(Object.assign({},t),{pbrMetallicRoughness:{baseColorFactor:te,baseColorTexture:ne},normalTexture:se,emissiveTexture:ue,emissiveFactor:ae,alphaMode:Z,alphaCutoff:K,doubleSided:J,extensions:{VRMC_materials_mtoon:Ne}})}_parseV0UnlitProperties(e,t){var i,n,r,o;const s="VRM/UnlitTransparentZWrite"===e.shader,a="VRM/UnlitTransparent"===e.shader||s,l=this._v0ParseRenderQueue(e),u="VRM/UnlitCutout"===e.shader,d=a?"BLEND":u?"MASK":"OPAQUE",h=u?null===(i=e.floatProperties)||void 0===i?void 0:i._Cutoff:void 0,c=this._portTextureTransform(e),p=null===(r=null===(n=e.vectorProperties)||void 0===n?void 0:n._Color)||void 0===r?void 0:r.map(he),m=null===(o=e.textureProperties)||void 0===o?void 0:o._MainTex,f=null!=m?{index:m,extensions:Object.assign({},c)}:void 0,v={specVersion:"1.0-beta",transparentWithZWrite:s,renderQueueOffsetNumber:l,shadeColorFactor:p,shadeMultiplyTexture:f};return Object.assign(Object.assign({},t),{pbrMetallicRoughness:{baseColorFactor:p,baseColorTexture:f},alphaMode:d,alphaCutoff:h,extensions:{VRMC_materials_mtoon:v}})}_portTextureTransform(e){var t,i,n,r,o;const s=null===(t=e.vectorProperties)||void 0===t?void 0:t._MainTex;if(null==s)return{};const a=[null!==(i=null==s?void 0:s[0])&&void 0!==i?i:0,null!==(n=null==s?void 0:s[1])&&void 0!==n?n:0],l=[null!==(r=null==s?void 0:s[2])&&void 0!==r?r:1,null!==(o=null==s?void 0:s[3])&&void 0!==o?o:1];return a[1]=l[1]*(1-a[1])%1,{KHR_texture_transform:{offset:a,scale:l}}}_v0ParseRenderQueue(e){var t,i,n;const r=null!==(i=null===(t=e.keywordMap)||void 0===t?void 0:t._ALPHABLEND_ON)&&void 0!==i&&i,o=1===(null===(n=e.floatProperties)||void 0===n?void 0:n._ZWrite);let s=0;return r&&e.renderQueue&&(s=o?Math.min(Math.max(e.renderQueue-2501,0),9):Math.min(Math.max(e.renderQueue-3e3,-9),0)),s}}
/*!
     * @pixiv/three-vrm-node-constraint v1.0.0-beta.7
     * Node constraint module for @pixiv/three-vrm
     *
     * Copyright (c) 2020-2021 pixiv Inc.
     * @pixiv/three-vrm-node-constraint is distributed under MIT License
     * https://github.com/pixiv/three-vrm/blob/release/LICENSE
     */const pe=new n.Vector3;class me extends n.Group{constructor(e){super(),this._attrPosition=new n.BufferAttribute(new Float32Array([0,0,0,0,0,0]),3),this._attrPosition.setUsage(n.DynamicDrawUsage);const t=new n.BufferGeometry;t.setAttribute("position",this._attrPosition);const i=new n.LineBasicMaterial({color:16711935,depthTest:!1,depthWrite:!1});this._line=new n.Line(t,i),this.add(this._line),this.constraint=e}updateMatrixWorld(e){pe.setFromMatrixPosition(this.constraint.object.matrixWorld),this._attrPosition.setXYZ(0,pe.x,pe.y,pe.z),this.constraint.source&&pe.setFromMatrixPosition(this.constraint.source.matrixWorld),this._attrPosition.setXYZ(1,pe.x,pe.y,pe.z),this._attrPosition.needsUpdate=!0,super.updateMatrixWorld(e)}}function fe(e,t){return t.set(e.elements[12],e.elements[13],e.elements[14])}const ve=new n.Vector3,ge=new n.Vector3;function _e(e,t){return e.decompose(ve,t,ge),t}function xe(e){return e.invert?e.invert():e.inverse(),e}const Me=new n.Vector3,ye=new n.Vector3,Te=new n.Vector3,Se=new n.Quaternion;const Re=new n.Matrix4;function we(e){return e.invert?e.invert():e.getInverse(Re.copy(e)),e}class Pe{constructor(e){this._inverseCache=new n.Matrix4,this._shouldUpdateInverse=!0,this.matrix=e;const t={set:(e,t,i)=>(this._shouldUpdateInverse=!0,e[t]=i,!0)};this._originalElements=e.elements,e.elements=new Proxy(e.elements,t)}get inverse(){return this._shouldUpdateInverse&&(this._inverseCache.copy(this.matrix),we(this._inverseCache),this._shouldUpdateInverse=!1),this._inverseCache}revert(){this.matrix.elements=this._originalElements}}const Ee=new n.Matrix4;class Le{constructor(e,t){this.weight=1,this.sourceSpace="model",this.destinationSpace="model",this.object=e,this.modelRoot=t}get source(){return this._source}get dependencies(){const e=new Set;return this._source&&e.add(this._source),"model"===this.destinationSpace&&this.object.parent&&e.add(this.object.parent),e}setSource(e){this._source=e}_getParentMatrixInModelSpace(e){return this.object.parent?(this.object.parent.updateWorldMatrix(!1,!1),e.copy(this.object.parent.matrixWorld),this._getMatrixWorldToModel(Ee),e.premultiply(Ee)):e.identity(),e}_getDestinationMatrix(e){if("local"===this.destinationSpace)this.object.updateMatrix(),e.copy(this.object.matrix);else{if("model"!==this.destinationSpace)throw new Error(`VRMNodeConstraint: Unknown destinationSpace ${this.destinationSpace} detected`);this.object.updateWorldMatrix(!1,!1),e.copy(this.object.matrixWorld),this._getMatrixWorldToModel(Ee),e.premultiply(Ee)}return e}_getSourceMatrix(e){if(!this._source)throw new Error("There is no source specified");if("local"===this.sourceSpace)this._source.updateMatrix(),e.copy(this._source.matrix);else{if("model"!==this.sourceSpace)throw new Error(`VRMNodeConstraint: Unknown sourceSpace ${this.sourceSpace} detected`);this._source.updateWorldMatrix(!1,!1),e.copy(this._source.matrixWorld),this._getMatrixWorldToModel(Ee),e.premultiply(Ee)}return e}_getMatrixWorldToModel(e){let t=this.modelRoot.userData.inverseCacheProxy;return t||(t=this.modelRoot.userData.inverseCacheProxy=new Pe(this.modelRoot.matrix)),e.copy(t.inverse),e}}const Ae=new n.Quaternion(0,0,0,1),be=new n.Quaternion,Ie=new n.Quaternion,Oe=new n.Matrix4,Ue=new n.Vector3,Ve=new n.Vector3;class Ce extends Le{constructor(){super(...arguments),this.aimVector=new n.Vector3(0,0,1),this.upVector=new n.Vector3(0,1,0),this.freezeAxes=[!0,!0],this._quatInitAim=new n.Quaternion,this._quatInvInitAim=new n.Quaternion,this._quatInitDst=new n.Quaternion}setInitState(){this._getDestinationMatrix(Oe),_e(Oe,this._quatInitDst),this._getAimQuat(this._quatInitAim),xe(this._quatInvInitAim.copy(this._quatInitAim))}update(){"local"===this.destinationSpace?this.object.quaternion.copy(Ae):(this._getParentMatrixInModelSpace(Oe),_e(Oe,be),xe(this.object.quaternion.copy(be))),this._getAimDiffQuat(Ie),this.object.quaternion.multiply(Ie),this.object.quaternion.multiply(this._quatInitDst),this.object.updateMatrix()}_getAimDiffQuat(e){return this._getAimQuat(e),e.multiply(this._quatInvInitAim),e.slerp(Ae,1-this.weight),e}_getAimQuat(e){return function(e,t,i,n,r,o){Me.copy(i).sub(t).normalize();const s=Math.asin(r.dot(n)),a=Math.asin(r.dot(Me));ye.crossVectors(r,n).normalize(),Te.crossVectors(ye,r);const l=Math.atan2(ye.dot(Me),Te.dot(Me));return e.setFromAxisAngle(r,o[0]?l:0),Se.setFromAxisAngle(ye,o[1]?s-a:0),e.multiply(Se),e}(e,this._getDestinationPosition(Ue),this._getSourcePosition(Ve),this.aimVector,this.upVector,this.freezeAxes)}_getDestinationPosition(e){return e.set(0,0,0),this._getDestinationMatrix(Oe),fe(Oe,e),e}_getSourcePosition(e){return e.set(0,0,0),this._source&&(this._getSourceMatrix(Oe),fe(Oe,e)),e}}
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */function Ne(e,t,i,n){return new(i||(i=Promise))((function(r,o){function s(e){try{l(n.next(e))}catch(e){o(e)}}function a(e){try{l(n.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?r(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(s,a)}l((n=n.apply(e,t||[])).next())}))}function Fe(e,t){const i=[];let n=e;for(;null!==n;)i.unshift(n),n=n.parent;i.forEach((e=>{t(e)}))}class De{constructor(){this._constraints=new Set,this._objectConstraintsMap=new Map}get constraints(){return this._constraints}addConstraint(e){this._constraints.add(e);let t=this._objectConstraintsMap.get(e.object);null==t&&(t=new Set,this._objectConstraintsMap.set(e.object,t)),t.add(e)}deleteConstraint(e){this._constraints.delete(e);this._objectConstraintsMap.get(e.object).delete(e)}setInitState(){const e=new Set,t=new Set;for(const i of this._constraints)this._processConstraint(i,e,t,(e=>e.setInitState()))}update(){const e=new Set,t=new Set;for(const i of this._constraints)this._processConstraint(i,e,t,(e=>e.update()))}_processConstraint(e,t,i,n){if(i.has(e))return;if(t.has(e))throw new Error("VRMConstraintManager: Circular dependency detected while updating constraints");t.add(e);const r=e.dependencies;for(const e of r)Fe(e,(e=>{const r=this._objectConstraintsMap.get(e);if(r)for(const e of r)this._processConstraint(e,t,i,n)}));n(e),i.add(e)}}const Be=new n.Matrix4;class ke extends Le{constructor(){super(...arguments),this.freezeAxes=[!0,!0,!0],this._v3InitDst=new n.Vector3,this._v3InitSrc=new n.Vector3}setInitState(){this._v3InitDst.copy(this.object.position),this._getSourcePosition(this._v3InitSrc)}update(){this._getSourceDiffPosition(this.object.position),"model"===this.destinationSpace&&(we(this._getParentMatrixInModelSpace(Be)),Be.elements[12]=0,Be.elements[13]=0,Be.elements[14]=0,this.object.position.applyMatrix4(Be)),this.object.position.add(this._v3InitDst),this.object.updateMatrix()}_getSourceDiffPosition(e){return this._getSourcePosition(e),e.sub(this._v3InitSrc),function(e,t){t[0]&&t[1]&&t[2]||(t[0]||t[1]||t[2]?(t[0]||(e.x*=0),t[1]||(e.y*=0),t[2]||(e.z*=0)):e.set(0,0,0))}(e,this.freezeAxes),e.multiplyScalar(this.weight),e}_getSourcePosition(e){return e.set(0,0,0),this._source&&(this._getSourceMatrix(Be),fe(Be,e)),e}}const We=new n.Quaternion(0,0,0,1),He=new n.Vector3;function je(e,t){return t[0]&&t[1]&&t[2]?e:t[0]||t[1]||t[2]?(function(e){He.set(e.x,e.y,e.z);const t=He.length(),i=t<Number.EPSILON?0:Math.atan2(t,e.w)/t;e.set(i*e.x,i*e.y,i*e.z,.5*Math.log(e.lengthSq()))}(e),t[0]||(e.x*=0),t[1]||(e.y*=0),t[2]||(e.z*=0),function(e){He.set(e.x,e.y,e.z);const t=He.length(),i=Math.exp(e.w),n=t<Number.EPSILON?0:i*Math.sin(t)/t;return e.set(n*e.x,n*e.y,n*e.z,i*Math.cos(t)),e}(e)):e.copy(We)}const ze=new n.Quaternion(0,0,0,1),Xe=new n.Matrix4,Ye=new n.Quaternion,Ge=new n.Quaternion;class qe extends Le{constructor(){super(...arguments),this.freezeAxes=[!0,!0,!0],this._quatInitSrc=new n.Quaternion,this._quatInvInitSrc=new n.Quaternion,this._quatInitDst=new n.Quaternion}setInitState(){this._quatInitDst.copy(this.object.quaternion),this._getSourceQuat(this._quatInitSrc),xe(this._quatInvInitSrc.copy(this._quatInitSrc))}update(){"local"===this.destinationSpace?this.object.quaternion.copy(this._quatInitDst):(this._getParentMatrixInModelSpace(Xe),_e(Xe,Ye),xe(this.object.quaternion.copy(Ye))),this._getSourceDiffQuat(Ge),this.object.quaternion.multiply(Ge),"model"===this.destinationSpace&&(this.object.quaternion.multiply(Ye),this.object.quaternion.multiply(this._quatInitDst)),this.object.updateMatrix()}_getSourceDiffQuat(e){return this._getSourceQuat(e),"local"===this.sourceSpace?e.premultiply(this._quatInvInitSrc):e.multiply(this._quatInvInitSrc),je(e,this.freezeAxes),e.slerp(ze,1-this.weight),e}_getSourceQuat(e){return e.copy(ze),this._source&&(this._getSourceMatrix(Xe),_e(Xe,e)),e}}class Qe{constructor(e,t){this.parser=e,this.helperRoot=null==t?void 0:t.helperRoot}get name(){return Qe.EXTENSION_NAME}afterRoot(e){return Ne(this,void 0,void 0,(function*(){e.userData.vrmNodeConstraintManager=yield this._import(e)}))}_import(e){var t;return Ne(this,void 0,void 0,(function*(){if(!(-1!==(null===(t=this.parser.json.extensionsUsed)||void 0===t?void 0:t.indexOf(Qe.EXTENSION_NAME))))return null;const i=new De,n=yield this.parser.getDependencies("node");return n.forEach(((t,r)=>{var o;const s=this.parser.json.nodes[r],a=null===(o=null==s?void 0:s.extensions)||void 0===o?void 0:o[Qe.EXTENSION_NAME];if(null==a)return;if("1.0-draft"===a.specVersion){if(null==a?void 0:a.position){const r=this._importPositionConstraint(t,n,e.scene,a.position);i.addConstraint(r)}if(null==a?void 0:a.rotation){const r=this._importRotationConstraint(t,n,e.scene,a.rotation);i.addConstraint(r)}if(null==a?void 0:a.aim){const r=this._importAimConstraint(t,n,e.scene,a.aim);i.addConstraint(r)}}})),e.scene.updateMatrixWorld(),i.setInitState(),i}))}_importPositionConstraint(e,t,i,n){const{source:r,sourceSpace:o,destinationSpace:s,weight:a,freezeAxes:l}=n,u=new ke(e,i);if(u.setSource(t[r]),o&&(u.sourceSpace=o),s&&(u.destinationSpace=s),a&&(u.weight=a),l&&(u.freezeAxes=l),this.helperRoot){const e=new me(u);this.helperRoot.add(e),e.renderOrder=this.helperRoot.renderOrder}return u}_importRotationConstraint(e,t,i,n){const{source:r,sourceSpace:o,destinationSpace:s,weight:a,freezeAxes:l}=n,u=new qe(e,i);if(u.setSource(t[r]),o&&(u.sourceSpace=o),s&&(u.destinationSpace=s),a&&(u.weight=a),l&&(u.freezeAxes=l),this.helperRoot){const e=new me(u);this.helperRoot.add(e)}return u}_importAimConstraint(e,t,i,n){const{source:r,aimVector:o,upVector:s,sourceSpace:a,destinationSpace:l,weight:u,freezeAxes:d}=n,h=new Ce(e,i);if(h.setSource(t[r]),o&&h.aimVector.fromArray(o).normalize(),s&&h.upVector.fromArray(s).normalize(),a&&(h.sourceSpace=a),l&&(h.destinationSpace=l),u&&(h.weight=u),d&&(h.freezeAxes=d),this.helperRoot){const e=new me(h);this.helperRoot.add(e)}return h}}Qe.EXTENSION_NAME="VRMC_node_constraint";
/*!
     * @pixiv/three-vrm-springbone v1.0.0-beta.7
     * Spring bone module for @pixiv/three-vrm
     *
     * Copyright (c) 2020-2021 pixiv Inc.
     * @pixiv/three-vrm-springbone is distributed under MIT License
     * https://github.com/pixiv/three-vrm/blob/release/LICENSE
     */
class $e{}const Ze=new n.Vector3,Ke=new n.Vector3;class Je extends $e{constructor(e){var t,i,r;super(),this.offset=null!==(t=null==e?void 0:e.offset)&&void 0!==t?t:new n.Vector3(0,0,0),this.tail=null!==(i=null==e?void 0:e.tail)&&void 0!==i?i:new n.Vector3(0,0,0),this.radius=null!==(r=null==e?void 0:e.radius)&&void 0!==r?r:1}get type(){return"capsule"}calculateCollision(e,t,i,n){Ze.copy(this.offset).applyMatrix4(e),Ke.copy(this.tail).applyMatrix4(e),Ke.sub(Ze);const r=Ke.lengthSq();n.copy(t).sub(Ze);const o=Ke.dot(n);o<=0||(r<=o||Ke.multiplyScalar(o/r),n.sub(Ke));const s=i+this.radius,a=n.length()-s;return n.normalize(),a}}class et extends $e{constructor(e){var t,i;super(),this.offset=null!==(t=null==e?void 0:e.offset)&&void 0!==t?t:new n.Vector3(0,0,0),this.radius=null!==(i=null==e?void 0:e.radius)&&void 0!==i?i:1}get type(){return"sphere"}calculateCollision(e,t,i,n){n.copy(this.offset).applyMatrix4(e),n.negate().add(t);const r=i+this.radius,o=n.length()-r;return n.normalize(),o}}const tt=new n.Vector3;class it extends n.BufferGeometry{constructor(e){super(),this._currentRadius=0,this._currentOffset=new n.Vector3,this._currentTail=new n.Vector3,this._shape=e,this._attrPos=new n.BufferAttribute(new Float32Array(396),3),this.setAttribute("position",this._attrPos),this._attrIndex=new n.BufferAttribute(new Uint16Array(264),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let e=!1;this._currentRadius!==this._shape.radius&&(this._currentRadius=this._shape.radius,e=!0),this._currentOffset.equals(this._shape.offset)||(this._currentOffset.copy(this._shape.offset),e=!0),this._currentTail.equals(this._shape.tail)||(this._currentTail.copy(this._shape.tail),e=!0),e&&this._buildPosition()}_buildPosition(){tt.copy(this._currentTail).sub(this._currentOffset);const e=tt.length()/this._currentRadius;for(let t=0;t<=16;t++){const i=t/16*Math.PI;this._attrPos.setXYZ(t,-Math.sin(i),-Math.cos(i),0),this._attrPos.setXYZ(17+t,e+Math.sin(i),Math.cos(i),0),this._attrPos.setXYZ(34+t,-Math.sin(i),0,-Math.cos(i)),this._attrPos.setXYZ(51+t,e+Math.sin(i),0,Math.cos(i))}for(let t=0;t<32;t++){const i=t/16*Math.PI;this._attrPos.setXYZ(68+t,0,Math.sin(i),Math.cos(i)),this._attrPos.setXYZ(100+t,e,Math.sin(i),Math.cos(i))}const t=Math.atan2(tt.y,Math.sqrt(tt.x*tt.x+tt.z*tt.z)),i=-Math.atan2(tt.z,tt.x);this.rotateZ(t),this.rotateY(i),this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentOffset.x,this._currentOffset.y,this._currentOffset.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let e=0;e<34;e++){const t=(e+1)%34;this._attrIndex.setXY(2*e,e,t),this._attrIndex.setXY(68+2*e,34+e,34+t)}for(let e=0;e<32;e++){const t=(e+1)%32;this._attrIndex.setXY(136+2*e,68+e,68+t),this._attrIndex.setXY(200+2*e,100+e,100+t)}this._attrIndex.needsUpdate=!0}}class nt extends n.BufferGeometry{constructor(e){super(),this._currentRadius=0,this._currentOffset=new n.Vector3,this._shape=e,this._attrPos=new n.BufferAttribute(new Float32Array(288),3),this.setAttribute("position",this._attrPos),this._attrIndex=new n.BufferAttribute(new Uint16Array(192),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let e=!1;this._currentRadius!==this._shape.radius&&(this._currentRadius=this._shape.radius,e=!0),this._currentOffset.equals(this._shape.offset)||(this._currentOffset.copy(this._shape.offset),e=!0),e&&this._buildPosition()}_buildPosition(){for(let e=0;e<32;e++){const t=e/16*Math.PI;this._attrPos.setXYZ(e,Math.cos(t),Math.sin(t),0),this._attrPos.setXYZ(32+e,0,Math.cos(t),Math.sin(t)),this._attrPos.setXYZ(64+e,Math.sin(t),0,Math.cos(t))}this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentOffset.x,this._currentOffset.y,this._currentOffset.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let e=0;e<32;e++){const t=(e+1)%32;this._attrIndex.setXY(2*e,e,t),this._attrIndex.setXY(64+2*e,32+e,32+t),this._attrIndex.setXY(128+2*e,64+e,64+t)}this._attrIndex.needsUpdate=!0}}class rt extends n.Group{constructor(e){if(super(),this.matrixAutoUpdate=!1,this.collider=e,this.collider.shape instanceof et)this._geometry=new nt(this.collider.shape);else{if(!(this.collider.shape instanceof Je))throw new Error("VRMSpringBoneColliderHelper: Unknown collider shape type detected");this._geometry=new it(this.collider.shape)}const t=new n.LineBasicMaterial({color:16711935,depthTest:!1,depthWrite:!1});this._line=new n.LineSegments(this._geometry,t),this.add(this._line)}dispose(){this._geometry.dispose()}updateMatrixWorld(e){this.collider.updateWorldMatrix(!0,!1),this.matrix.copy(this.collider.matrixWorld),this._geometry.update(),super.updateMatrixWorld(e)}}class ot extends n.BufferGeometry{constructor(e){super(),this._currentRadius=0,this._currentTail=new n.Vector3,this._springBone=e,this._attrPos=new n.BufferAttribute(new Float32Array(294),3),this.setAttribute("position",this._attrPos),this._attrIndex=new n.BufferAttribute(new Uint16Array(194),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let e=!1;this._currentRadius!==this._springBone.settings.hitRadius&&(this._currentRadius=this._springBone.settings.hitRadius,e=!0),this._currentTail.equals(this._springBone.initialLocalChildPosition)||(this._currentTail.copy(this._springBone.initialLocalChildPosition),e=!0),e&&this._buildPosition()}_buildPosition(){for(let e=0;e<32;e++){const t=e/16*Math.PI;this._attrPos.setXYZ(e,Math.cos(t),Math.sin(t),0),this._attrPos.setXYZ(32+e,0,Math.cos(t),Math.sin(t)),this._attrPos.setXYZ(64+e,Math.sin(t),0,Math.cos(t))}this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.setXYZ(96,0,0,0),this._attrPos.setXYZ(97,this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let e=0;e<32;e++){const t=(e+1)%32;this._attrIndex.setXY(2*e,e,t),this._attrIndex.setXY(64+2*e,32+e,32+t),this._attrIndex.setXY(128+2*e,64+e,64+t)}this._attrIndex.setXY(192,96,97),this._attrIndex.needsUpdate=!0}}class st extends n.Group{constructor(e){super(),this.matrixAutoUpdate=!1,this.springBone=e,this._geometry=new ot(this.springBone);const t=new n.LineBasicMaterial({color:16776960,depthTest:!1,depthWrite:!1});this._line=new n.LineSegments(this._geometry,t),this.add(this._line)}dispose(){this._geometry.dispose()}updateMatrixWorld(e){this.springBone.bone.updateWorldMatrix(!0,!1),this.matrix.copy(this.springBone.bone.matrixWorld),this._geometry.update(),super.updateMatrixWorld(e)}}class at extends n.Object3D{constructor(e){super(),this.shape=e}}const lt=new n.Vector3,ut=new n.Vector3;const dt=new n.Matrix4;function ht(e){return e.invert?e.invert():e.getInverse(dt.copy(e)),e}class ct{constructor(e){this._inverseCache=new n.Matrix4,this._shouldUpdateInverse=!0,this.matrix=e;const t={set:(e,t,i)=>(this._shouldUpdateInverse=!0,e[t]=i,!0)};this._originalElements=e.elements,e.elements=new Proxy(e.elements,t)}get inverse(){return this._shouldUpdateInverse&&(this._inverseCache.copy(this.matrix),ht(this._inverseCache),this._shouldUpdateInverse=!1),this._inverseCache}revert(){this.matrix.elements=this._originalElements}}const pt=Object.freeze(new n.Matrix4),mt=Object.freeze(new n.Quaternion),ft=new n.Vector3,vt=new n.Vector3,gt=new n.Quaternion,_t=new n.Matrix4,xt=new n.Matrix4;class Mt{constructor(e,t,i={},r=[]){var o,s,a,l,u,d;this._currentTail=new n.Vector3,this._prevTail=new n.Vector3,this._nextTail=new n.Vector3,this._boneAxis=new n.Vector3,this._centerSpaceBoneLength=0,this._centerSpacePosition=new n.Vector3,this._center=null,this._parentWorldRotation=new n.Quaternion,this._initialLocalMatrix=new n.Matrix4,this._initialLocalRotation=new n.Quaternion,this._initialLocalChildPosition=new n.Vector3,this.bone=e,this.bone.matrixAutoUpdate=!1,this.child=t,this.settings={hitRadius:null!==(o=i.hitRadius)&&void 0!==o?o:0,stiffness:null!==(s=i.stiffness)&&void 0!==s?s:1,gravityPower:null!==(a=i.gravityPower)&&void 0!==a?a:0,gravityDir:null!==(u=null===(l=i.gravityDir)||void 0===l?void 0:l.clone())&&void 0!==u?u:new n.Vector3(0,-1,0),dragForce:null!==(d=i.dragForce)&&void 0!==d?d:.4},this.colliderGroups=r}get center(){return this._center}set center(e){var t;this._getMatrixCenterToWorld(_t),this._currentTail.applyMatrix4(_t),this._prevTail.applyMatrix4(_t),this._nextTail.applyMatrix4(_t),(null===(t=this._center)||void 0===t?void 0:t.userData.inverseCacheProxy)&&(this._center.userData.inverseCacheProxy.revert(),delete this._center.userData.inverseCacheProxy),this._center=e,this._center&&(this._center.userData.inverseCacheProxy||(this._center.userData.inverseCacheProxy=new ct(this._center.matrixWorld))),this._getMatrixWorldToCenter(_t),this._currentTail.applyMatrix4(_t),this._prevTail.applyMatrix4(_t),this._nextTail.applyMatrix4(_t),_t.multiply(this.bone.matrixWorld),this._centerSpacePosition.setFromMatrixPosition(_t),this._centerSpaceBoneLength=ft.copy(this._initialLocalChildPosition).applyMatrix4(_t).sub(this._centerSpacePosition).length()}get initialLocalChildPosition(){return this._initialLocalChildPosition}setInitState(){this.bone.updateMatrix(),this.bone.updateWorldMatrix(!1,!1),this._centerSpacePosition.setFromMatrixPosition(this.bone.matrixWorld),this._initialLocalMatrix.copy(this.bone.matrix),this._initialLocalRotation.copy(this.bone.quaternion),this.child?this._initialLocalChildPosition.copy(this.child.position):this._initialLocalChildPosition.copy(this.bone.position).normalize().multiplyScalar(.07),this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)),this._prevTail.copy(this._currentTail),this._nextTail.copy(this._currentTail),this._boneAxis.copy(this._initialLocalChildPosition).normalize(),this._centerSpaceBoneLength=ft.copy(this._initialLocalChildPosition).applyMatrix4(this.bone.matrixWorld).sub(this._centerSpacePosition).length()}reset(){this.bone.quaternion.copy(this._initialLocalRotation),this.bone.updateMatrix(),this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(),this.bone.matrix),this._centerSpacePosition.setFromMatrixPosition(this.bone.matrixWorld),this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)),this._prevTail.copy(this._currentTail),this._nextTail.copy(this._currentTail)}update(e){if(e<=0)return;var t,i;this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(),this.bone.matrix),this.bone.parent?(t=this.bone.parent,i=this._parentWorldRotation,t.matrixWorld.decompose(lt,i,ut)):this._parentWorldRotation.copy(mt),this._getMatrixWorldToCenter(_t),_t.multiply(this.bone.matrixWorld),this._centerSpacePosition.setFromMatrixPosition(_t),this._getMatrixWorldToCenter(xt),xt.multiply(this._getParentMatrixWorld());const n=this.settings.stiffness*e,r=vt.copy(this.settings.gravityDir).multiplyScalar(this.settings.gravityPower*e);this._nextTail.copy(this._currentTail).add(ft.copy(this._currentTail).sub(this._prevTail).multiplyScalar(1-this.settings.dragForce)).add(ft.copy(this._boneAxis).applyMatrix4(this._initialLocalMatrix).applyMatrix4(xt).sub(this._centerSpacePosition).normalize().multiplyScalar(n)).add(r),this._nextTail.sub(this._centerSpacePosition).normalize().multiplyScalar(this._centerSpaceBoneLength).add(this._centerSpacePosition),this._collision(this._nextTail),this._prevTail.copy(this._currentTail),this._currentTail.copy(this._nextTail);const o=ht(_t.copy(xt.multiply(this._initialLocalMatrix))),s=gt.setFromUnitVectors(this._boneAxis,ft.copy(this._nextTail).applyMatrix4(o).normalize());this.bone.quaternion.copy(this._initialLocalRotation).multiply(s),this.bone.updateMatrix(),this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(),this.bone.matrix)}_collision(e){this.colliderGroups.forEach((t=>{t.colliders.forEach((t=>{this._getMatrixWorldToCenter(_t),_t.multiply(t.matrixWorld);const i=t.shape.calculateCollision(_t,e,this.settings.hitRadius,ft);i<0&&(e.add(ft.multiplyScalar(-i)),e.sub(this._centerSpacePosition).normalize().multiplyScalar(this._centerSpaceBoneLength).add(this._centerSpacePosition))}))}))}_getMatrixCenterToWorld(e){return this._center?e.copy(this._center.matrixWorld):e.identity(),e}_getMatrixWorldToCenter(e){return this._center?e.copy(this._center.userData.inverseCacheProxy.inverse):e.identity(),e}_getParentMatrixWorld(){return this.bone.parent?this.bone.parent.matrixWorld:pt}}
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */function yt(e,t,i,n){return new(i||(i=Promise))((function(r,o){function s(e){try{l(n.next(e))}catch(e){o(e)}}function a(e){try{l(n.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?r(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(s,a)}l((n=n.apply(e,t||[])).next())}))}function Tt(e,t){const i=[];let n=e;for(;null!==n;)i.unshift(n),n=n.parent;i.forEach((e=>{t(e)}))}function St(e,t){e.children.forEach((e=>{t(e)||St(e,t)}))}class Rt{constructor(){this._springBones=new Set,this._objectSpringBonesMap=new Map}get springBones(){return this._springBones}get colliderGroups(){const e=new Set;return this._springBones.forEach((t=>{t.colliderGroups.forEach((t=>{e.add(t)}))})),Array.from(e)}get colliders(){const e=new Set;return this.colliderGroups.forEach((t=>{t.colliders.forEach((t=>{e.add(t)}))})),Array.from(e)}addSpringBone(e){this._springBones.add(e);let t=this._objectSpringBonesMap.get(e.bone);null==t&&(t=new Set,this._objectSpringBonesMap.set(e.bone,t)),t.add(e)}deleteSpringBone(e){this._springBones.delete(e);this._objectSpringBonesMap.get(e.bone).delete(e)}setInitState(){const e=new Set,t=new Set;for(const i of this._springBones)this._processSpringBone(i,e,t,(e=>e.setInitState()))}reset(){const e=new Set,t=new Set;for(const i of this._springBones)this._processSpringBone(i,e,t,(e=>e.reset()))}update(e){const t=new Set,i=new Set;for(const n of this._springBones)this._processSpringBone(n,t,i,(t=>t.update(e))),St(n.bone,(e=>{var t,i;return(null!==(i=null===(t=this._objectSpringBonesMap.get(e))||void 0===t?void 0:t.size)&&void 0!==i?i:0)>0||(e.updateWorldMatrix(!1,!1),!1)}))}_processSpringBone(e,t,i,n){if(i.has(e))return;if(t.has(e))throw new Error("VRMSpringBoneManager: Circular dependency detected while updating constraints");t.add(e);const r=this._getDependencies(e);for(const e of r)Tt(e,(e=>{const r=this._objectSpringBonesMap.get(e);if(r)for(const e of r)this._processSpringBone(e,t,i,n)}));n(e),i.add(e)}_getDependencies(e){const t=new Set,i=e.bone.parent;return i&&t.add(i),t}}class wt{constructor(e,t){this.parser=e,this.jointHelperRoot=null==t?void 0:t.jointHelperRoot,this.colliderHelperRoot=null==t?void 0:t.colliderHelperRoot}get name(){return wt.EXTENSION_NAME}afterRoot(e){return yt(this,void 0,void 0,(function*(){e.userData.vrmSpringBoneManager=yield this._import(e)}))}_import(e){return yt(this,void 0,void 0,(function*(){const t=yield this._v1Import(e);if(null!=t)return t;const i=yield this._v0Import(e);return null!=i?i:null}))}_v1Import(e){var t,i,r,o,s;return yt(this,void 0,void 0,(function*(){if(!(-1!==(null===(t=e.parser.json.extensionsUsed)||void 0===t?void 0:t.indexOf(wt.EXTENSION_NAME))))return null;const a=new Rt,l=yield e.parser.getDependencies("node"),u=null===(i=e.parser.json.extensions)||void 0===i?void 0:i[wt.EXTENSION_NAME];if(!u)return null;if("1.0-beta"!==u.specVersion)return null;const d=null===(r=u.colliders)||void 0===r?void 0:r.map(((e,t)=>{var i,r,o,s,a;const u=l[e.node],d=e.shape;if(d.sphere)return this._importSphereCollider(u,{offset:(new n.Vector3).fromArray(null!==(i=d.sphere.offset)&&void 0!==i?i:[0,0,0]),radius:null!==(r=d.sphere.radius)&&void 0!==r?r:0});if(d.capsule)return this._importCapsuleCollider(u,{offset:(new n.Vector3).fromArray(null!==(o=d.capsule.offset)&&void 0!==o?o:[0,0,0]),radius:null!==(s=d.capsule.radius)&&void 0!==s?s:0,tail:(new n.Vector3).fromArray(null!==(a=d.capsule.tail)&&void 0!==a?a:[0,0,0])});throw new Error(`VRMSpringBoneLoaderPlugin: The collider #${t} has no valid shape`)})),h=null===(o=u.colliderGroups)||void 0===o?void 0:o.map(((e,t)=>{var i;return{colliders:(null!==(i=e.colliders)&&void 0!==i?i:[]).map((e=>{const i=null==d?void 0:d[e];if(null==i)throw new Error(`VRMSpringBoneLoaderPlugin: The colliderGroup #${t} attempted to use a collider #${e} but not found`);return i})),name:e.name}}));return null===(s=u.springs)||void 0===s||s.forEach(((e,t)=>{var i;const r=e.joints,o=null===(i=e.colliderGroups)||void 0===i?void 0:i.map((e=>{const i=null==h?void 0:h[e];if(null==i)throw new Error(`VRMSpringBoneLoaderPlugin: The spring #${t} attempted to use a colliderGroup ${e} but not found`);return i}));let s;r.forEach((e=>{var t;if(s){const i=s.node,r=l[i],u=e.node,d=l[u],h={hitRadius:s.hitRadius,dragForce:s.dragForce,gravityPower:s.gravityPower,stiffness:s.stiffness,gravityDir:(new n.Vector3).fromArray(null!==(t=s.gravityDir)&&void 0!==t?t:[0,1,0])},c=this._importJoint(r,d,h,o);a.addSpringBone(c)}s=e}))})),e.scene.updateMatrixWorld(),a.setInitState(),a}))}_v0Import(e){var t,i,r;return yt(this,void 0,void 0,(function*(){if(!(-1!==(null===(t=e.parser.json.extensionsUsed)||void 0===t?void 0:t.indexOf("VRM"))))return null;const o=null===(i=e.parser.json.extensions)||void 0===i?void 0:i.VRM,s=null==o?void 0:o.secondaryAnimation;if(!s)return null;const a=null==s?void 0:s.boneGroups;if(!a)return null;const l=new Rt,u=yield e.parser.getDependencies("node"),d=null===(r=s.colliderGroups)||void 0===r?void 0:r.map((e=>{var t;const i=u[e.node];return{colliders:(null!==(t=e.colliders)&&void 0!==t?t:[]).map(((e,t)=>{var r,o,s;const a=new n.Vector3(0,0,0);return e.offset&&a.set(null!==(r=e.offset.x)&&void 0!==r?r:0,null!==(o=e.offset.y)&&void 0!==o?o:0,e.offset.z?-e.offset.z:0),this._importSphereCollider(i,{offset:a,radius:null!==(s=e.radius)&&void 0!==s?s:0})}))}}));return null==a||a.forEach(((e,t)=>{const i=e.bones;i&&i.forEach((i=>{var r,o,s,a;const h=u[i],c=new n.Vector3;e.gravityDir?c.set(null!==(r=e.gravityDir.x)&&void 0!==r?r:0,null!==(o=e.gravityDir.y)&&void 0!==o?o:0,null!==(s=e.gravityDir.z)&&void 0!==s?s:0):c.set(0,-1,0);const p={hitRadius:e.hitRadius,dragForce:e.dragForce,gravityPower:e.gravityPower,stiffness:e.stiffiness,gravityDir:c},m=null===(a=e.colliderGroups)||void 0===a?void 0:a.map((e=>{const i=null==d?void 0:d[e];if(null==i)throw new Error(`VRMSpringBoneLoaderPlugin: The spring #${t} attempted to use a colliderGroup ${e} but not found`);return i}));h.traverse((e=>{var t;const i=null!==(t=e.children[0])&&void 0!==t?t:null,n=this._importJoint(e,i,p,m);l.addSpringBone(n)}))}))})),e.scene.updateMatrixWorld(),l.setInitState(),l}))}_importJoint(e,t,i,n){const r=new Mt(e,t,i,n);if(this.jointHelperRoot){const e=new st(r);this.jointHelperRoot.add(e),e.renderOrder=this.jointHelperRoot.renderOrder}return r}_importSphereCollider(e,t){const{offset:i,radius:n}=t,r=new et({offset:i,radius:n}),o=new at(r);if(e.add(o),this.colliderHelperRoot){const e=new rt(o);this.colliderHelperRoot.add(e),e.renderOrder=this.colliderHelperRoot.renderOrder}return o}_importCapsuleCollider(e,t){const{offset:i,radius:n,tail:r}=t,o=new Je({offset:i,radius:n,tail:r}),s=new at(o);if(e.add(s),this.colliderHelperRoot){const e=new rt(s);this.colliderHelperRoot.add(e),e.renderOrder=this.colliderHelperRoot.renderOrder}return s}}wt.EXTENSION_NAME="VRMC_springBone";function Pt(e){if(Object.values(e).forEach((e=>{if(null==e?void 0:e.isTexture){e.dispose()}})),e.isShaderMaterial){const t=e.uniforms;t&&Object.values(t).forEach((e=>{const t=e.value;if(null==t?void 0:t.isTexture){t.dispose()}}))}e.dispose()}function Et(e){const t=e.geometry;t&&t.dispose();const i=e.skeleton;i&&i.dispose();const n=e.material;n&&(Array.isArray(n)?n.forEach((e=>Pt(e))):n&&Pt(n))}class Lt{constructor(){}}Lt.deepDispose=function(e){e.traverse(Et)},Lt.removeUnnecessaryJoints=function(e){const t=new Map;e.traverse((e=>{if("SkinnedMesh"!==e.type)return;const i=e,r=i.geometry.getAttribute("skinIndex");let o=t.get(r);if(!o){const e=[],s=[],a={},l=r.array;for(let t=0;t<l.length;t++){const n=l[t];void 0===a[n]&&(a[n]=e.length,e.push(i.skeleton.bones[n]),s.push(i.skeleton.boneInverses[n])),l[t]=a[n]}r.copyArray(l),r.needsUpdate=!0,o=new n.Skeleton(e,s),t.set(r,o)}i.bind(o,new n.Matrix4)}))},Lt.removeUnnecessaryVertices=function(e){const i=new Map;e.traverse((e=>{if(!e.isMesh)return;const r=e,o=r.geometry,s=o.index;if(null==s)return;const a=i.get(o);if(null!=a)return void(r.geometry=a);const l=new n.BufferGeometry;l.morphTargetsRelative=o.morphTargetsRelative,l.setDrawRange(o.drawRange.start,o.drawRange.count),o.groups.forEach((e=>{l.addGroup(e.start,e.count,e.materialIndex)})),i.set(o,l);const u=[],d=[];{const e=s.array,i=new e.constructor(e.length);let n=0;for(let t=0;t<e.length;t++){const r=e[t];let o=u[r];null==o&&(u[r]=n,d[n]=r,o=n,n++),i[t]=o}l.setIndex(new t.BufferAttribute(i,1,!1))}Object.keys(o.attributes).forEach((e=>{const i=o.attributes[e];if(i.isInterleavedBufferAttribute)throw new Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported");const n=i.array,{itemSize:r,normalized:s}=i,a=new n.constructor(d.length*r);d.forEach(((e,t)=>{for(let i=0;i<r;i++)a[t*r+i]=n[e*r+i]})),l.setAttribute(e,new t.BufferAttribute(a,r,s))}));let h=!0;Object.keys(o.morphAttributes).forEach((e=>{l.morphAttributes[e]=[];const i=o.morphAttributes[e];for(let n=0;n<i.length;n++){const r=i[n];if(r.isInterleavedBufferAttribute)throw new Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported");const o=r.array,{itemSize:s,normalized:a}=r,u=new o.constructor(d.length*s);d.forEach(((e,t)=>{for(let i=0;i<s;i++)u[t*s+i]=o[e*s+i]})),h=h&&u.every((e=>0===e)),l.morphAttributes[e][n]=new t.BufferAttribute(u,s,a)}})),h&&(l.morphAttributes={}),r.geometry=l})),Array.from(i.keys()).forEach((e=>{e.dispose()}))},Lt.rotateVRM0=function(e){var t;"0"===(null===(t=e.meta)||void 0===t?void 0:t.metaVersion)&&(e.scene.rotation.y=Math.PI)},e.MToonMaterial=oe,e.MToonMaterialDebugMode=ie,e.MToonMaterialLoaderPlugin=ae,e.MToonMaterialOutlineWidthMode=ne,e.VRM=K,e.VRMAimConstraint=Ce,e.VRMCore=Z,e.VRMCoreLoaderPlugin=class{constructor(e,t){var i,n,r,o,s;this.parser=e;const a=null==t?void 0:t.helperRoot;this.expressionPlugin=null!==(i=null==t?void 0:t.expressionPlugin)&&void 0!==i?i:new _(e),this.firstPersonPlugin=null!==(n=null==t?void 0:t.firstPersonPlugin)&&void 0!==n?n:new M(e),this.humanoidPlugin=null!==(r=null==t?void 0:t.humanoidPlugin)&&void 0!==r?r:new P(e),this.lookAtPlugin=null!==(o=null==t?void 0:t.lookAtPlugin)&&void 0!==o?o:new Q(e,{helperRoot:a}),this.metaPlugin=null!==(s=null==t?void 0:t.metaPlugin)&&void 0!==s?s:new $(e)}get name(){return"VRMC_vrm"}afterRoot(e){return o(this,void 0,void 0,(function*(){yield this.metaPlugin.afterRoot(e),yield this.humanoidPlugin.afterRoot(e),yield this.expressionPlugin.afterRoot(e),yield this.lookAtPlugin.afterRoot(e),yield this.firstPersonPlugin.afterRoot(e);const t=new Z({scene:e.scene,expressionManager:e.userData.vrmExpressionManager,firstPerson:e.userData.vrmFirstPerson,humanoid:e.userData.vrmHumanoid,lookAt:e.userData.vrmLookAt,meta:e.userData.vrmMeta});e.userData.vrmCore=t}))}},e.VRMExpression=r,e.VRMExpressionLoaderPlugin=_,e.VRMExpressionManager=c,e.VRMExpressionMaterialColorType={Color:"color",EmissionColor:"emissionColor",ShadeColor:"shadeColor",RimColor:"rimColor",OutlineColor:"outlineColor"},e.VRMExpressionOverrideType={None:"none",Block:"block",Blend:"blend"},e.VRMExpressionPresetName=d,e.VRMFirstPerson=x,e.VRMFirstPersonLoaderPlugin=M,e.VRMFirstPersonMeshAnnotationType={Auto:"auto",Both:"both",ThirdPersonOnly:"thirdPersonOnly",FirstPersonOnly:"firstPersonOnly"},e.VRMHumanBoneName={Hips:"hips",Spine:"spine",Chest:"chest",UpperChest:"upperChest",Neck:"neck",Head:"head",LeftEye:"leftEye",RightEye:"rightEye",Jaw:"jaw",LeftUpperLeg:"leftUpperLeg",LeftLowerLeg:"leftLowerLeg",LeftFoot:"leftFoot",LeftToes:"leftToes",RightUpperLeg:"rightUpperLeg",RightLowerLeg:"rightLowerLeg",RightFoot:"rightFoot",RightToes:"rightToes",LeftShoulder:"leftShoulder",LeftUpperArm:"leftUpperArm",LeftLowerArm:"leftLowerArm",LeftHand:"leftHand",RightShoulder:"rightShoulder",RightUpperArm:"rightUpperArm",RightLowerArm:"rightLowerArm",RightHand:"rightHand",LeftThumbProximal:"leftThumbProximal",LeftThumbIntermediate:"leftThumbIntermediate",LeftThumbDistal:"leftThumbDistal",LeftIndexProximal:"leftIndexProximal",LeftIndexIntermediate:"leftIndexIntermediate",LeftIndexDistal:"leftIndexDistal",LeftMiddleProximal:"leftMiddleProximal",LeftMiddleIntermediate:"leftMiddleIntermediate",LeftMiddleDistal:"leftMiddleDistal",LeftRingProximal:"leftRingProximal",LeftRingIntermediate:"leftRingIntermediate",LeftRingDistal:"leftRingDistal",LeftLittleProximal:"leftLittleProximal",LeftLittleIntermediate:"leftLittleIntermediate",LeftLittleDistal:"leftLittleDistal",RightThumbProximal:"rightThumbProximal",RightThumbIntermediate:"rightThumbIntermediate",RightThumbDistal:"rightThumbDistal",RightIndexProximal:"rightIndexProximal",RightIndexIntermediate:"rightIndexIntermediate",RightIndexDistal:"rightIndexDistal",RightMiddleProximal:"rightMiddleProximal",RightMiddleIntermediate:"rightMiddleIntermediate",RightMiddleDistal:"rightMiddleDistal",RightRingProximal:"rightRingProximal",RightRingIntermediate:"rightRingIntermediate",RightRingDistal:"rightRingDistal",RightLittleProximal:"rightLittleProximal",RightLittleIntermediate:"rightLittleIntermediate",RightLittleDistal:"rightLittleDistal"},e.VRMHumanoid=R,e.VRMHumanoidLoaderPlugin=P,e.VRMLoaderPlugin=class{constructor(e,t){var i,n,r,o,s,a,l,u,d,h;this.parser=e;const c=null==t?void 0:t.helperRoot;this.expressionPlugin=null!==(i=null==t?void 0:t.expressionPlugin)&&void 0!==i?i:new _(e),this.firstPersonPlugin=null!==(n=null==t?void 0:t.firstPersonPlugin)&&void 0!==n?n:new M(e),this.humanoidPlugin=null!==(r=null==t?void 0:t.humanoidPlugin)&&void 0!==r?r:new P(e),this.lookAtPlugin=null!==(o=null==t?void 0:t.lookAtPlugin)&&void 0!==o?o:new Q(e,{helperRoot:c}),this.metaPlugin=null!==(s=null==t?void 0:t.metaPlugin)&&void 0!==s?s:new $(e),this.mtoonMaterialPlugin=null!==(a=null==t?void 0:t.mtoonMaterialPlugin)&&void 0!==a?a:new ae(e),this.materialsHDREmissiveMultiplierPlugin=null!==(l=null==t?void 0:t.materialsHDREmissiveMultiplierPlugin)&&void 0!==l?l:new ue(e),this.materialsV0CompatPlugin=null!==(u=null==t?void 0:t.materialsV0CompatPlugin)&&void 0!==u?u:new ce(e),this.springBonePlugin=null!==(d=null==t?void 0:t.springBonePlugin)&&void 0!==d?d:new wt(e,{colliderHelperRoot:c,jointHelperRoot:c}),this.constraintPlugin=null!==(h=null==t?void 0:t.constraintPlugin)&&void 0!==h?h:new Qe(e,{helperRoot:c})}get name(){return"VRMLoaderPlugin"}beforeRoot(){return J(this,void 0,void 0,(function*(){yield this.materialsV0CompatPlugin.beforeRoot(),yield this.mtoonMaterialPlugin.beforeRoot()}))}loadMesh(e){return J(this,void 0,void 0,(function*(){return yield this.mtoonMaterialPlugin.loadMesh(e)}))}getMaterialType(e){const t=this.mtoonMaterialPlugin.getMaterialType(e);return null!=t?t:null}extendMaterialParams(e,t){return J(this,void 0,void 0,(function*(){yield this.mtoonMaterialPlugin.extendMaterialParams(e,t)}))}afterRoot(e){return J(this,void 0,void 0,(function*(){yield this.metaPlugin.afterRoot(e),yield this.humanoidPlugin.afterRoot(e),yield this.expressionPlugin.afterRoot(e),yield this.lookAtPlugin.afterRoot(e),yield this.firstPersonPlugin.afterRoot(e),yield this.springBonePlugin.afterRoot(e),yield this.constraintPlugin.afterRoot(e),yield this.mtoonMaterialPlugin.afterRoot(e),yield this.materialsHDREmissiveMultiplierPlugin.afterRoot(e);const t=new K({scene:e.scene,expressionManager:e.userData.vrmExpressionManager,firstPerson:e.userData.vrmFirstPerson,humanoid:e.userData.vrmHumanoid,lookAt:e.userData.vrmLookAt,meta:e.userData.vrmMeta,materials:e.userData.vrmMToonMaterials,springBoneManager:e.userData.vrmSpringBoneManager,constraintManager:e.userData.vrmConstraintManager});e.userData.vrm=t}))}},e.VRMLookAt=z,e.VRMLookAtBoneApplier=Y,e.VRMLookAtExpressionApplier=G,e.VRMLookAtHelper=N,e.VRMLookAtLoaderPlugin=Q,e.VRMLookAtRangeMap=q,e.VRMLookAtTypeName={Bone:"bone",Expression:"expression"},e.VRMMetaLoaderPlugin=$,e.VRMNodeConstraint=Le,e.VRMNodeConstraintHelper=me,e.VRMNodeConstraintLoaderPlugin=Qe,e.VRMNodeConstraintManager=De,e.VRMNodeConstraintObjectSpace={Local:"local",Model:"model"},e.VRMPositionConstraint=ke,e.VRMRequiredHumanBoneName=w,e.VRMRotationConstraint=qe,e.VRMSpringBoneCollider=at,e.VRMSpringBoneColliderHelper=rt,e.VRMSpringBoneColliderShape=$e,e.VRMSpringBoneColliderShapeCapsule=Je,e.VRMSpringBoneColliderShapeSphere=et,e.VRMSpringBoneJoint=Mt,e.VRMSpringBoneJointHelper=st,e.VRMSpringBoneLoaderPlugin=wt,e.VRMSpringBoneManager=Rt,e.VRMUtils=Lt,Object.defineProperty(e,"__esModule",{value:!0}),Object.assign(t,e)}));
