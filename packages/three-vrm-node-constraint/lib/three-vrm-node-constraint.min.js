/*! (c) 2020-2021 pixiv Inc. - https://github.com/pixiv/three-vrm/blob/release/LICENSE */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE_VRM_NODE_CONSTRAINT={},t.THREE)}(this,(function(t,e){"use strict";function i(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(i){if("default"!==i){var n=Object.getOwnPropertyDescriptor(t,i);Object.defineProperty(e,i,n.get?n:{enumerable:!0,get:function(){return t[i]}})}})),e.default=t,Object.freeze(e)}var n=i(e);const o=new n.Vector3;class s extends n.Group{constructor(t){super(),this._attrPosition=new n.BufferAttribute(new Float32Array([0,0,0,0,0,0]),3),this._attrPosition.setUsage(n.DynamicDrawUsage);const e=new n.BufferGeometry;e.setAttribute("position",this._attrPosition);const i=new n.LineBasicMaterial({color:16711935,depthTest:!1,depthWrite:!1});this._line=new n.Line(e,i),this.add(this._line),this.constraint=t}updateMatrixWorld(t){o.setFromMatrixPosition(this.constraint.object.matrixWorld),this._attrPosition.setXYZ(0,o.x,o.y,o.z),this.constraint.source&&o.setFromMatrixPosition(this.constraint.source.matrixWorld),this._attrPosition.setXYZ(1,o.x,o.y,o.z),this._attrPosition.needsUpdate=!0,super.updateMatrixWorld(t)}}function r(t,e){return e.set(t.elements[12],t.elements[13],t.elements[14])}const a=new n.Vector3,c=new n.Vector3;function u(t,e){return t.decompose(a,e,c),e}function h(t){return t.invert?t.invert():t.inverse(),t}const d=new n.Vector3,l=new n.Vector3,p=new n.Vector3,_=new n.Quaternion;const f=new n.Matrix4;function m(t){return t.invert?t.invert():t.getInverse(f.copy(t)),t}class S{constructor(t){this._inverseCache=new n.Matrix4,this._shouldUpdateInverse=!0,this.matrix=t;const e={set:(t,e,i)=>(this._shouldUpdateInverse=!0,t[e]=i,!0)};this._originalElements=t.elements,t.elements=new Proxy(t.elements,e)}get inverse(){return this._shouldUpdateInverse&&(this._inverseCache.copy(this.matrix),m(this._inverseCache),this._shouldUpdateInverse=!1),this._inverseCache}revert(){this.matrix.elements=this._originalElements}}const x=new n.Matrix4;class w{constructor(t,e){this.weight=1,this.sourceSpace="model",this.destinationSpace="model",this.object=t,this.modelRoot=e}get source(){return this._source}get dependencies(){const t=new Set;return this._source&&t.add(this._source),"model"===this.destinationSpace&&this.object.parent&&t.add(this.object.parent),t}setSource(t){this._source=t}_getParentMatrixInModelSpace(t){return this.object.parent?(this.object.parent.updateWorldMatrix(!1,!1),t.copy(this.object.parent.matrixWorld),this._getMatrixWorldToModel(x),t.premultiply(x)):t.identity(),t}_getDestinationMatrix(t){if("local"===this.destinationSpace)this.object.updateMatrix(),t.copy(this.object.matrix);else{if("model"!==this.destinationSpace)throw new Error(`VRMNodeConstraint: Unknown destinationSpace ${this.destinationSpace} detected`);this.object.updateWorldMatrix(!1,!1),t.copy(this.object.matrixWorld),this._getMatrixWorldToModel(x),t.premultiply(x)}return t}_getSourceMatrix(t){if(!this._source)throw new Error("There is no source specified");if("local"===this.sourceSpace)this._source.updateMatrix(),t.copy(this._source.matrix);else{if("model"!==this.sourceSpace)throw new Error(`VRMNodeConstraint: Unknown sourceSpace ${this.sourceSpace} detected`);this._source.updateWorldMatrix(!1,!1),t.copy(this._source.matrixWorld),this._getMatrixWorldToModel(x),t.premultiply(x)}return t}_getMatrixWorldToModel(t){let e=this.modelRoot.userData.inverseCacheProxy;return e||(e=this.modelRoot.userData.inverseCacheProxy=new S(this.modelRoot.matrix)),t.copy(e.inverse),t}}const M=new n.Quaternion(0,0,0,1),g=new n.Quaternion,y=new n.Quaternion,v=new n.Matrix4,I=new n.Vector3,b=new n.Vector3;class j extends w{constructor(){super(...arguments),this.aimVector=new n.Vector3(0,0,1),this.upVector=new n.Vector3(0,1,0),this.freezeAxes=[!0,!0],this._quatInitAim=new n.Quaternion,this._quatInvInitAim=new n.Quaternion,this._quatInitDst=new n.Quaternion}setInitState(){this._getDestinationMatrix(v),u(v,this._quatInitDst),this._getAimQuat(this._quatInitAim),h(this._quatInvInitAim.copy(this._quatInitAim))}update(){"local"===this.destinationSpace?this.object.quaternion.copy(M):(this._getParentMatrixInModelSpace(v),u(v,g),h(this.object.quaternion.copy(g))),this._getAimDiffQuat(y),this.object.quaternion.multiply(y),this.object.quaternion.multiply(this._quatInitDst),this.object.updateMatrix()}_getAimDiffQuat(t){return this._getAimQuat(t),t.multiply(this._quatInvInitAim),t.slerp(M,1-this.weight),t}_getAimQuat(t){return function(t,e,i,n,o,s){d.copy(i).sub(e).normalize();const r=Math.asin(o.dot(n)),a=Math.asin(o.dot(d));l.crossVectors(o,n).normalize(),p.crossVectors(l,o);const c=Math.atan2(l.dot(d),p.dot(d));return t.setFromAxisAngle(o,s[0]?c:0),_.setFromAxisAngle(l,s[1]?r-a:0),t.multiply(_),t}(t,this._getDestinationPosition(I),this._getSourcePosition(b),this.aimVector,this.upVector,this.freezeAxes)}_getDestinationPosition(t){return t.set(0,0,0),this._getDestinationMatrix(v),r(v,t),t}_getSourcePosition(t){return t.set(0,0,0),this._source&&(this._getSourceMatrix(v),r(v,t)),t}}
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */function C(t,e,i,n){return new(i||(i=Promise))((function(o,s){function r(t){try{c(n.next(t))}catch(t){s(t)}}function a(t){try{c(n.throw(t))}catch(t){s(t)}}function c(t){var e;t.done?o(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(r,a)}c((n=n.apply(t,e||[])).next())}))}function A(t,e){const i=[];let n=t;for(;null!==n;)i.unshift(n),n=n.parent;i.forEach((t=>{e(t)}))}class V{constructor(){this._constraints=new Set,this._objectConstraintsMap=new Map}get constraints(){return this._constraints}addConstraint(t){this._constraints.add(t);let e=this._objectConstraintsMap.get(t.object);null==e&&(e=new Set,this._objectConstraintsMap.set(t.object,e)),e.add(t)}deleteConstraint(t){this._constraints.delete(t);this._objectConstraintsMap.get(t.object).delete(t)}setInitState(){const t=new Set,e=new Set;for(const i of this._constraints)this._processConstraint(i,t,e,(t=>t.setInitState()))}update(){const t=new Set,e=new Set;for(const i of this._constraints)this._processConstraint(i,t,e,(t=>t.update()))}_processConstraint(t,e,i,n){if(i.has(t))return;if(e.has(t))throw new Error("VRMConstraintManager: Circular dependency detected while updating constraints");e.add(t);const o=t.dependencies;for(const t of o)A(t,(t=>{const o=this._objectConstraintsMap.get(t);if(o)for(const t of o)this._processConstraint(t,e,i,n)}));n(t),i.add(t)}}const P=new n.Matrix4;class R extends w{constructor(){super(...arguments),this.freezeAxes=[!0,!0,!0],this._v3InitDst=new n.Vector3,this._v3InitSrc=new n.Vector3}setInitState(){this._v3InitDst.copy(this.object.position),this._getSourcePosition(this._v3InitSrc)}update(){this._getSourceDiffPosition(this.object.position),"model"===this.destinationSpace&&(m(this._getParentMatrixInModelSpace(P)),P.elements[12]=0,P.elements[13]=0,P.elements[14]=0,this.object.position.applyMatrix4(P)),this.object.position.add(this._v3InitDst),this.object.updateMatrix()}_getSourceDiffPosition(t){return this._getSourcePosition(t),t.sub(this._v3InitSrc),function(t,e){e[0]&&e[1]&&e[2]||(e[0]||e[1]||e[2]?(e[0]||(t.x*=0),e[1]||(t.y*=0),e[2]||(t.z*=0)):t.set(0,0,0))}(t,this.freezeAxes),t.multiplyScalar(this.weight),t}_getSourcePosition(t){return t.set(0,0,0),this._source&&(this._getSourceMatrix(P),r(P,t)),t}}const q=new n.Quaternion(0,0,0,1),D=new n.Vector3;function E(t,e){return e[0]&&e[1]&&e[2]?t:e[0]||e[1]||e[2]?(function(t){D.set(t.x,t.y,t.z);const e=D.length(),i=e<Number.EPSILON?0:Math.atan2(e,t.w)/e;t.set(i*t.x,i*t.y,i*t.z,.5*Math.log(t.lengthSq()))}(t),e[0]||(t.x*=0),e[1]||(t.y*=0),e[2]||(t.z*=0),function(t){D.set(t.x,t.y,t.z);const e=D.length(),i=Math.exp(t.w),n=e<Number.EPSILON?0:i*Math.sin(e)/e;return t.set(n*t.x,n*t.y,n*t.z,i*Math.cos(e)),t}(t)):t.copy(q)}const N=new n.Quaternion(0,0,0,1),z=new n.Matrix4,Q=new n.Quaternion,O=new n.Quaternion;class T extends w{constructor(){super(...arguments),this.freezeAxes=[!0,!0,!0],this._quatInitSrc=new n.Quaternion,this._quatInvInitSrc=new n.Quaternion,this._quatInitDst=new n.Quaternion}setInitState(){this._quatInitDst.copy(this.object.quaternion),this._getSourceQuat(this._quatInitSrc),h(this._quatInvInitSrc.copy(this._quatInitSrc))}update(){"local"===this.destinationSpace?this.object.quaternion.copy(this._quatInitDst):(this._getParentMatrixInModelSpace(z),u(z,Q),h(this.object.quaternion.copy(Q))),this._getSourceDiffQuat(O),this.object.quaternion.multiply(O),"model"===this.destinationSpace&&(this.object.quaternion.multiply(Q),this.object.quaternion.multiply(this._quatInitDst)),this.object.updateMatrix()}_getSourceDiffQuat(t){return this._getSourceQuat(t),"local"===this.sourceSpace?t.premultiply(this._quatInvInitSrc):t.multiply(this._quatInvInitSrc),E(t,this.freezeAxes),t.slerp(N,1-this.weight),t}_getSourceQuat(t){return t.copy(N),this._source&&(this._getSourceMatrix(z),u(z,t)),t}}class W{constructor(t,e){this.parser=t,this.helperRoot=null==e?void 0:e.helperRoot}get name(){return W.EXTENSION_NAME}afterRoot(t){return C(this,void 0,void 0,(function*(){t.userData.vrmNodeConstraintManager=yield this._import(t)}))}_import(t){var e;return C(this,void 0,void 0,(function*(){if(!(-1!==(null===(e=this.parser.json.extensionsUsed)||void 0===e?void 0:e.indexOf(W.EXTENSION_NAME))))return null;const i=new V,n=yield this.parser.getDependencies("node");return n.forEach(((e,o)=>{var s;const r=this.parser.json.nodes[o],a=null===(s=null==r?void 0:r.extensions)||void 0===s?void 0:s[W.EXTENSION_NAME];if(null==a)return;if("1.0-draft"===a.specVersion){if(null==a?void 0:a.position){const o=this._importPositionConstraint(e,n,t.scene,a.position);i.addConstraint(o)}if(null==a?void 0:a.rotation){const o=this._importRotationConstraint(e,n,t.scene,a.rotation);i.addConstraint(o)}if(null==a?void 0:a.aim){const o=this._importAimConstraint(e,n,t.scene,a.aim);i.addConstraint(o)}}})),t.scene.updateMatrixWorld(),i.setInitState(),i}))}_importPositionConstraint(t,e,i,n){const{source:o,sourceSpace:r,destinationSpace:a,weight:c,freezeAxes:u}=n,h=new R(t,i);if(h.setSource(e[o]),r&&(h.sourceSpace=r),a&&(h.destinationSpace=a),c&&(h.weight=c),u&&(h.freezeAxes=u),this.helperRoot){const t=new s(h);this.helperRoot.add(t),t.renderOrder=this.helperRoot.renderOrder}return h}_importRotationConstraint(t,e,i,n){const{source:o,sourceSpace:r,destinationSpace:a,weight:c,freezeAxes:u}=n,h=new T(t,i);if(h.setSource(e[o]),r&&(h.sourceSpace=r),a&&(h.destinationSpace=a),c&&(h.weight=c),u&&(h.freezeAxes=u),this.helperRoot){const t=new s(h);this.helperRoot.add(t)}return h}_importAimConstraint(t,e,i,n){const{source:o,aimVector:r,upVector:a,sourceSpace:c,destinationSpace:u,weight:h,freezeAxes:d}=n,l=new j(t,i);if(l.setSource(e[o]),r&&l.aimVector.fromArray(r).normalize(),a&&l.upVector.fromArray(a).normalize(),c&&(l.sourceSpace=c),u&&(l.destinationSpace=u),h&&(l.weight=h),d&&(l.freezeAxes=d),this.helperRoot){const t=new s(l);this.helperRoot.add(t)}return l}}W.EXTENSION_NAME="VRMC_node_constraint";t.VRMAimConstraint=j,t.VRMNodeConstraint=w,t.VRMNodeConstraintHelper=s,t.VRMNodeConstraintLoaderPlugin=W,t.VRMNodeConstraintManager=V,t.VRMNodeConstraintObjectSpace={Local:"local",Model:"model"},t.VRMPositionConstraint=R,t.VRMRotationConstraint=T,Object.defineProperty(t,"__esModule",{value:!0}),Object.assign(e,t)}));
