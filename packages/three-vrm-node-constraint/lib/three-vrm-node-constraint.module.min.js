/*! (c) 2020-2021 pixiv Inc. - https://github.com/pixiv/three-vrm/blob/release/LICENSE */
import*as t from"three";const e=new t.Vector3;class i extends t.Group{constructor(e){super(),this._attrPosition=new t.BufferAttribute(new Float32Array([0,0,0,0,0,0]),3),this._attrPosition.setUsage(t.DynamicDrawUsage);const i=new t.BufferGeometry;i.setAttribute("position",this._attrPosition);const n=new t.LineBasicMaterial({color:16711935,depthTest:!1,depthWrite:!1});this._line=new t.Line(i,n),this.add(this._line),this.constraint=e}updateMatrixWorld(t){e.setFromMatrixPosition(this.constraint.object.matrixWorld),this._attrPosition.setXYZ(0,e.x,e.y,e.z),this.constraint.source&&e.setFromMatrixPosition(this.constraint.source.matrixWorld),this._attrPosition.setXYZ(1,e.x,e.y,e.z),this._attrPosition.needsUpdate=!0,super.updateMatrixWorld(t)}}function n(t,e){return e.set(t.elements[12],t.elements[13],t.elements[14])}const s=new t.Vector3,o=new t.Vector3;function r(t,e){return t.decompose(s,e,o),e}function a(t){return t.invert?t.invert():t.inverse(),t}const c=new t.Vector3,h=new t.Vector3,u=new t.Vector3,d=new t.Quaternion;const l=new t.Matrix4;function p(t){return t.invert?t.invert():t.getInverse(l.copy(t)),t}class _{constructor(e){this._inverseCache=new t.Matrix4,this._shouldUpdateInverse=!0,this.matrix=e;const i={set:(t,e,i)=>(this._shouldUpdateInverse=!0,t[e]=i,!0)};this._originalElements=e.elements,e.elements=new Proxy(e.elements,i)}get inverse(){return this._shouldUpdateInverse&&(this._inverseCache.copy(this.matrix),p(this._inverseCache),this._shouldUpdateInverse=!1),this._inverseCache}revert(){this.matrix.elements=this._originalElements}}const m=new t.Matrix4;class f{constructor(t,e){this.weight=1,this.sourceSpace="model",this.destinationSpace="model",this.object=t,this.modelRoot=e}get source(){return this._source}get dependencies(){const t=new Set;return this._source&&t.add(this._source),"model"===this.destinationSpace&&this.object.parent&&t.add(this.object.parent),t}setSource(t){this._source=t}_getParentMatrixInModelSpace(t){return this.object.parent?(this.object.parent.updateWorldMatrix(!1,!1),t.copy(this.object.parent.matrixWorld),this._getMatrixWorldToModel(m),t.premultiply(m)):t.identity(),t}_getDestinationMatrix(t){if("local"===this.destinationSpace)this.object.updateMatrix(),t.copy(this.object.matrix);else{if("model"!==this.destinationSpace)throw new Error(`VRMNodeConstraint: Unknown destinationSpace ${this.destinationSpace} detected`);this.object.updateWorldMatrix(!1,!1),t.copy(this.object.matrixWorld),this._getMatrixWorldToModel(m),t.premultiply(m)}return t}_getSourceMatrix(t){if(!this._source)throw new Error("There is no source specified");if("local"===this.sourceSpace)this._source.updateMatrix(),t.copy(this._source.matrix);else{if("model"!==this.sourceSpace)throw new Error(`VRMNodeConstraint: Unknown sourceSpace ${this.sourceSpace} detected`);this._source.updateWorldMatrix(!1,!1),t.copy(this._source.matrixWorld),this._getMatrixWorldToModel(m),t.premultiply(m)}return t}_getMatrixWorldToModel(t){let e=this.modelRoot.userData.inverseCacheProxy;return e||(e=this.modelRoot.userData.inverseCacheProxy=new _(this.modelRoot.matrix)),t.copy(e.inverse),t}}const S=new t.Quaternion(0,0,0,1),w=new t.Quaternion,x=new t.Quaternion,M=new t.Matrix4,g=new t.Vector3,y=new t.Vector3;class I extends f{constructor(){super(...arguments),this.aimVector=new t.Vector3(0,0,1),this.upVector=new t.Vector3(0,1,0),this.freezeAxes=[!0,!0],this._quatInitAim=new t.Quaternion,this._quatInvInitAim=new t.Quaternion,this._quatInitDst=new t.Quaternion}setInitState(){this._getDestinationMatrix(M),r(M,this._quatInitDst),this._getAimQuat(this._quatInitAim),a(this._quatInvInitAim.copy(this._quatInitAim))}update(){"local"===this.destinationSpace?this.object.quaternion.copy(S):(this._getParentMatrixInModelSpace(M),r(M,w),a(this.object.quaternion.copy(w))),this._getAimDiffQuat(x),this.object.quaternion.multiply(x),this.object.quaternion.multiply(this._quatInitDst),this.object.updateMatrix()}_getAimDiffQuat(t){return this._getAimQuat(t),t.multiply(this._quatInvInitAim),t.slerp(S,1-this.weight),t}_getAimQuat(t){return function(t,e,i,n,s,o){c.copy(i).sub(e).normalize();const r=Math.asin(s.dot(n)),a=Math.asin(s.dot(c));h.crossVectors(s,n).normalize(),u.crossVectors(h,s);const l=Math.atan2(h.dot(c),u.dot(c));return t.setFromAxisAngle(s,o[0]?l:0),d.setFromAxisAngle(h,o[1]?r-a:0),t.multiply(d),t}(t,this._getDestinationPosition(g),this._getSourcePosition(y),this.aimVector,this.upVector,this.freezeAxes)}_getDestinationPosition(t){return t.set(0,0,0),this._getDestinationMatrix(M),n(M,t),t}_getSourcePosition(t){return t.set(0,0,0),this._source&&(this._getSourceMatrix(M),n(M,t)),t}}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function v(t,e,i,n){return new(i||(i=Promise))((function(s,o){function r(t){try{c(n.next(t))}catch(t){o(t)}}function a(t){try{c(n.throw(t))}catch(t){o(t)}}function c(t){var e;t.done?s(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(r,a)}c((n=n.apply(t,e||[])).next())}))}function b(t,e){const i=[];let n=t;for(;null!==n;)i.unshift(n),n=n.parent;i.forEach((t=>{e(t)}))}class j{constructor(){this._constraints=new Set,this._objectConstraintsMap=new Map}get constraints(){return this._constraints}addConstraint(t){this._constraints.add(t);let e=this._objectConstraintsMap.get(t.object);null==e&&(e=new Set,this._objectConstraintsMap.set(t.object,e)),e.add(t)}deleteConstraint(t){this._constraints.delete(t);this._objectConstraintsMap.get(t.object).delete(t)}setInitState(){const t=new Set,e=new Set;for(const i of this._constraints)this._processConstraint(i,t,e,(t=>t.setInitState()))}update(){const t=new Set,e=new Set;for(const i of this._constraints)this._processConstraint(i,t,e,(t=>t.update()))}_processConstraint(t,e,i,n){if(i.has(t))return;if(e.has(t))throw new Error("VRMConstraintManager: Circular dependency detected while updating constraints");e.add(t);const s=t.dependencies;for(const t of s)b(t,(t=>{const s=this._objectConstraintsMap.get(t);if(s)for(const t of s)this._processConstraint(t,e,i,n)}));n(t),i.add(t)}}const A=new t.Matrix4;class C extends f{constructor(){super(...arguments),this.freezeAxes=[!0,!0,!0],this._v3InitDst=new t.Vector3,this._v3InitSrc=new t.Vector3}setInitState(){this._v3InitDst.copy(this.object.position),this._getSourcePosition(this._v3InitSrc)}update(){this._getSourceDiffPosition(this.object.position),"model"===this.destinationSpace&&(p(this._getParentMatrixInModelSpace(A)),A.elements[12]=0,A.elements[13]=0,A.elements[14]=0,this.object.position.applyMatrix4(A)),this.object.position.add(this._v3InitDst),this.object.updateMatrix()}_getSourceDiffPosition(t){return this._getSourcePosition(t),t.sub(this._v3InitSrc),function(t,e){e[0]&&e[1]&&e[2]||(e[0]||e[1]||e[2]?(e[0]||(t.x*=0),e[1]||(t.y*=0),e[2]||(t.z*=0)):t.set(0,0,0))}(t,this.freezeAxes),t.multiplyScalar(this.weight),t}_getSourcePosition(t){return t.set(0,0,0),this._source&&(this._getSourceMatrix(A),n(A,t)),t}}const q=new t.Quaternion(0,0,0,1),P=new t.Vector3;function V(t,e){return e[0]&&e[1]&&e[2]?t:e[0]||e[1]||e[2]?(function(t){P.set(t.x,t.y,t.z);const e=P.length(),i=e<Number.EPSILON?0:Math.atan2(e,t.w)/e;t.set(i*t.x,i*t.y,i*t.z,.5*Math.log(t.lengthSq()))}(t),e[0]||(t.x*=0),e[1]||(t.y*=0),e[2]||(t.z*=0),function(t){P.set(t.x,t.y,t.z);const e=P.length(),i=Math.exp(t.w),n=e<Number.EPSILON?0:i*Math.sin(e)/e;return t.set(n*t.x,n*t.y,n*t.z,i*Math.cos(e)),t}(t)):t.copy(q)}const D=new t.Quaternion(0,0,0,1),z=new t.Matrix4,Q=new t.Quaternion,E=new t.Quaternion;class R extends f{constructor(){super(...arguments),this.freezeAxes=[!0,!0,!0],this._quatInitSrc=new t.Quaternion,this._quatInvInitSrc=new t.Quaternion,this._quatInitDst=new t.Quaternion}setInitState(){this._quatInitDst.copy(this.object.quaternion),this._getSourceQuat(this._quatInitSrc),a(this._quatInvInitSrc.copy(this._quatInitSrc))}update(){"local"===this.destinationSpace?this.object.quaternion.copy(this._quatInitDst):(this._getParentMatrixInModelSpace(z),r(z,Q),a(this.object.quaternion.copy(Q))),this._getSourceDiffQuat(E),this.object.quaternion.multiply(E),"model"===this.destinationSpace&&(this.object.quaternion.multiply(Q),this.object.quaternion.multiply(this._quatInitDst)),this.object.updateMatrix()}_getSourceDiffQuat(t){return this._getSourceQuat(t),"local"===this.sourceSpace?t.premultiply(this._quatInvInitSrc):t.multiply(this._quatInvInitSrc),V(t,this.freezeAxes),t.slerp(D,1-this.weight),t}_getSourceQuat(t){return t.copy(D),this._source&&(this._getSourceMatrix(z),r(z,t)),t}}class N{constructor(t,e){this.parser=t,this.helperRoot=null==e?void 0:e.helperRoot}get name(){return N.EXTENSION_NAME}afterRoot(t){return v(this,void 0,void 0,(function*(){t.userData.vrmNodeConstraintManager=yield this._import(t)}))}_import(t){var e;return v(this,void 0,void 0,(function*(){if(!(-1!==(null===(e=this.parser.json.extensionsUsed)||void 0===e?void 0:e.indexOf(N.EXTENSION_NAME))))return null;const i=new j,n=yield this.parser.getDependencies("node");return n.forEach(((e,s)=>{var o;const r=this.parser.json.nodes[s],a=null===(o=null==r?void 0:r.extensions)||void 0===o?void 0:o[N.EXTENSION_NAME];if(null==a)return;if("1.0-draft"===a.specVersion){if(null==a?void 0:a.position){const s=this._importPositionConstraint(e,n,t.scene,a.position);i.addConstraint(s)}if(null==a?void 0:a.rotation){const s=this._importRotationConstraint(e,n,t.scene,a.rotation);i.addConstraint(s)}if(null==a?void 0:a.aim){const s=this._importAimConstraint(e,n,t.scene,a.aim);i.addConstraint(s)}}})),t.scene.updateMatrixWorld(),i.setInitState(),i}))}_importPositionConstraint(t,e,n,s){const{source:o,sourceSpace:r,destinationSpace:a,weight:c,freezeAxes:h}=s,u=new C(t,n);if(u.setSource(e[o]),r&&(u.sourceSpace=r),a&&(u.destinationSpace=a),c&&(u.weight=c),h&&(u.freezeAxes=h),this.helperRoot){const t=new i(u);this.helperRoot.add(t),t.renderOrder=this.helperRoot.renderOrder}return u}_importRotationConstraint(t,e,n,s){const{source:o,sourceSpace:r,destinationSpace:a,weight:c,freezeAxes:h}=s,u=new R(t,n);if(u.setSource(e[o]),r&&(u.sourceSpace=r),a&&(u.destinationSpace=a),c&&(u.weight=c),h&&(u.freezeAxes=h),this.helperRoot){const t=new i(u);this.helperRoot.add(t)}return u}_importAimConstraint(t,e,n,s){const{source:o,aimVector:r,upVector:a,sourceSpace:c,destinationSpace:h,weight:u,freezeAxes:d}=s,l=new I(t,n);if(l.setSource(e[o]),r&&l.aimVector.fromArray(r).normalize(),a&&l.upVector.fromArray(a).normalize(),c&&(l.sourceSpace=c),h&&(l.destinationSpace=h),u&&(l.weight=u),d&&(l.freezeAxes=d),this.helperRoot){const t=new i(l);this.helperRoot.add(t)}return l}}N.EXTENSION_NAME="VRMC_node_constraint";const W={Local:"local",Model:"model"};export{I as VRMAimConstraint,f as VRMNodeConstraint,i as VRMNodeConstraintHelper,N as VRMNodeConstraintLoaderPlugin,j as VRMNodeConstraintManager,W as VRMNodeConstraintObjectSpace,C as VRMPositionConstraint,R as VRMRotationConstraint};
